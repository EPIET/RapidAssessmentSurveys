---
title: "RAS module R case study code" 
subtitle: "Childhood vaccination coverage survey in Greece, 2006"
author: "Amy Mikhail and Alexander Spina (Applied Epi)"
date: "Date revised: 27 May 2022"
output:
  html_document:
    code_folding: hide
    toc: true
    toc_float:
      toc_collapsed: true
    toc_depth: 3
  pdf_document:
    toc: true
    toc_depth: 3
  word_document:
    toc: true
    toc_depth: 3
theme: sandstone
geometry: margin = 1.5cm
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      eval = TRUE,
                      message = FALSE, 
                      warning = FALSE, 
                      ft.align = "left",
                      fig.width = 12,
                      out.width = "100%")
```

### Introduction

This R markdown document contains all the code required to complete the Rapid Assessments and Surveys (RAS) module vaccination coverage case study tasks in R.  

You may wish to run the code as is at first, then use the code chunks below to modify and experiment with different function arguments as needed.  

You can also copy the code from these chunks to a new R script or R markdown document and adapt to your own data, if you are undertaking a vaccine coverage survey with similar design.

Happy R coding!


## S0: Setup

### 01. Installing required packages:

```{r packages, results='hide', message=FALSE, warning=FALSE}

# Packages to install *before* running pacman pload():
#####################################################

# Ensures the package "pacman" is installed
if (!require("pacman")) install.packages("pacman", quiet = TRUE)

# Ensure the package "remotes" is installed
if (!require("remotes")) install.packages("remotes", quiet = TRUE)

# Install the epikit package from Github:
if (!require("epikit")) remotes::install_github("R4EPI/epikit", quiet = TRUE)

# Install the sitrep package from Github:
if (!require("sitrep")) remotes::install_github("R4EPI/sitrep", quiet = TRUE)


# Install and/or load required packages:
########################################
pacman::p_load(
  
  # Project and file management
  #############################
  here,      # file paths relative to R project root folder
  rio,       # import/export of many types of data
  rmarkdown, # reading and printing RAS R markdown guide
  knitr,     # reading and printing RAS R markdown guide
  
  # Package install and management
  ################################
  pacman,   # package install/load
  remotes,  # install from github
  
  # General data management
  #########################
  tidyverse,   # includes many packages for tidy data wrangling:
  #dplyr,      # data management
  #tidyr,      # data management
  #ggplot2,    # data visualization
  #stringr,    # work with strings and characters
  #forcats,    # work with factors 
  #lubridate,  # work with dates
  #purrr       # iteration and working with lists
  janitor,     # data cleaning
  matchmaker,  # data cleaning
  
  # Summary tables:
  #########################
  flextable,   # Creating printable summary tables
  officer,     # Fine tuning flextables
  gtsummary,   # making descriptive and statistical tables
  smd,         # Helper functions for gtsummary tables
  labelled,    # Labelling variables and values
  scales,      # helper functions
  Hmisc,       # Summary functions
  
  # Analysis:
  #########################
  pps,         # Probability proportional to size (PPS) sampling
  sampler,     # Calculate sample size
  srvyr,       # Create survey design and calculate vaccination coverage
  survey,      # Support for srvyr functions
  fixest,      # Multivariable models with multiple fixed effects
  broom.mixed  # Extract tidy table of mixed effects model results
)

# Check for and install Github packages:
pacman::p_load_gh(
  
  # Packages for survey analysis and mixed effects:
  #################################################
  "R4EPI/epikit",     # Functions for survey analysis
  "R4EPI/sitrep"      # Function wrappers for survey analysis
)

```

## S1: Sampling strategies

### 1.2: Stratified proportional sampling


***Table 1.2 -** Updated with proportions and number of classes to
sample per stratum*

```{r sframe_import}

# Import sample frame for regions:
regions <- rio::import(here::here("data", "Sampling_frames.xlsx"),
                         which = "table1_2")

# Create new table for results:
nclasses2sample <- regions %>% 
  
  # Convert table to tidy data:
  tidyr::pivot_longer(cols = c(Urban, Rural),        # Convert to tidy format
                      names_to = "Stratum",          # Store strata in new col
                      values_to = "Population") %>%  # Store population in new col
  
  # Calculate proportions and number of classes to sample:
  mutate(Proportion = Population/Total,              # Calculate proportions
         Nclasses = round(50*Proportion, digits = 0))# Calculate number of classes


#################
# Print results:
################

# Convert to a flextable:
nclasses2sample_pub <- flextable::qflextable(nclasses2sample) %>% 
  flextable::autofit()

# Print:
nclasses2sample_pub

```

\newpage

### 1.3: Simple random sampling

***Table 1.3 -** Simple Random Sample of 22 school classes*

```{r simple_random_sample}

# Import the sampling frame of school classes in Peleponissos-Sterea:
class_frame <- rio::import(here::here("data", "Sampling_frames.xlsx"),
                         which = "table1_3")

# Perform a simple random sample to select 22 classes from the list:
msrs <- class_frame %>% 
  
  # Subset the simple random sample of 22 classes:
  slice_sample(n = 22) %>% 
  
  # Arrange results in ascending order by ID:
  dplyr::arrange(ID)

#################
# Print results:
################

# Convert to flextable:
msrs_pub <- flextable::qflextable(msrs) %>% 
  flextable::autofit()

# Print:
msrs_pub

```

Calculate sampling fraction:

```{r sample_fraction}

# Calculate the sampling fraction for this example:
sample_fraction <- round(22/nrow(class_frame), digits = 2)

#################
# Print results:
################

sample_fraction

```


### 1.4: Systematic sampling


***Table 1.4 -** Systematic sample of school classes*

```{r systematic_sample}

# Define the sampling interval - the n to systematically sample 
# (i.e. every nth row to choose):
sample_n <- as.integer(nrow(class_frame)/22)

# Calculate the random starting point for systematic sampling:
sample_start <- sample.int(n = sample_n, size = 1)

# Define rows systematically (every nth row) to filter the sampling frame: 
sample_rows <- seq.int(sample_start, nrow(class_frame), sample_n)

# Now subset the sampling frame and filter for every nth row:
msystematic <- class_frame %>% 
  
  # Select every nth row from the sampling frame:
  slice(sample_rows) %>% 
  
  # Limit the number of returned rows to the desired sample size (22)
  slice_head(n = 22)

#################
# Print results:
################

# Convert to flextable:
msystematic_pub <- flextable::qflextable(msystematic) %>% 
  flextable::autofit()

msystematic_pub

```


### 1.5: PPS sampling


***Table 1.5 -** School classes selected by Probability Proportional to
Size sampling*

```{r pps_sample}

# Import the sampling frame of urban schools with grade 1 classes in Attiki:
school_frame <- rio::import(here::here("data", "Sampling_frames.xlsx"), 
                            which = "table1_5")

# Perform PPS sampling to select 12 schools:
mpps <- school_frame %>% 
  
  # Select schools by PPS without replacement:
  slice(pps::sampford(size = Students, n = 12)) %>% 
  
  # Arrange in ascending order by ID:
  arrange(ID)

#################
# Print results:
################

# Convert to flextable:
mpps_pub <- flextable::qflextable(mpps) %>% 
  flextable::autofit()

# Print:
mpps_pub

```


## S2: Sample size

### 2.1: Single proportion sample size

***Table 2.1 -** Estimated sample size by region and urban / rural
residence area*

```{r sample_size_basic}

#########################
# Import data
#########################

# Import the sampling frame of urban schools with grade 1 classes in Attiki:
region_frame <- rio::import(here::here("data", "Sampling_frames.xlsx"), 
                            which = "table2_1")

#########################
# Calculate sample size
#########################


# Calculate sample size (number of students to survey) for each region:
region_frame <- region_frame %>% 
  
  # Create new column fpc and calculate per-region sample size
  # (with finite population correction):
  mutate(fpc = sampler::rsampcalc(N = Student_pop, 
                                          e = 4, 
                                          ci = 95, 
                                          p = 0.85, 
                                          over = 0)) %>% 
  
  # Create new column buffer and calculate sample size again
  # this time adding a buffer for a response rate of 87.5%:
  mutate(buffer = sampler::rsampcalc(N = Student_pop, 
                                          e = 4, 
                                          ci = 95, 
                                          p = 0.85, 
                                          over = 1 - 0.875))

#########################
# Present in a table
#########################

rfpub <- region_frame %>% 
  
  # Convert data.frame to flextable:
  flextable::qflextable()

# Print the table:
rfpub

```


### 2.3: Sample size in R


***Table 2.3 -** Regional sample size with adjustments for population,
non-responders & design effect*

```{r sample_size_icc}

# Calculate the design effect given n = 20 and rho = 0.05:
deff <- 1 + (20 - 1) * 0.05

# Add new rho-adjusted sample size calculation to the table:
region_frame <- region_frame %>% 
  
  # Calculate sample size with adjustment for the design effect:
  mutate(ndeff = round(buffer * deff, digits = 0))

# Calculate the number of clusters (school classes) required:
nclusters <- round((sum(region_frame$ndeff)) / 20, digits = 0)

#################
# Print results:
################

# Print number of clusters required:
nclusters

# Convert to flextable:
rfpub <- flextable::qflextable(region_frame) %>% 
  flextable::autofit()

# Print table:
rfpub

```



## S4: Estimate VC


### 4.1: Sample representativeness


To ensure that the variables of interest are summarised correctly, we
will convert them from the binary numeric format output from STATA to
categorical labelled factors:

```{r s42_dataprep}

#################################################
# IMPORT DATA, LABEL VARIABLES AND FACTOR LEVELS
#################################################

# Import the vaccine coverage study data for session 4:
vaccine <- rio::import(here::here("data", "vaccine4.dta"))  %>% 
  
  # Convert vaccrec to a factor and add nice display labels:
  mutate(vaccrec = factor(vaccrec, 
                          levels = c(0, 1), 
                          labels = c("Non-respondents", "Respondents"))) %>% 
  
  # Convert gender to a labelled factor:
  mutate(gender = factor(gender,
                         levels = c(0, 1),
                         labels = c("Female", "Male"))) %>% 
  
  # Convert residence area type to a labelled factor:
  mutate(urban = factor(urban, 
                        levels = c(0, 1),
                        labels = c("Rural", "Urban"))) %>% 

  
  # Convert minority to a factor and add nice display labels:
  mutate(minority = factor(minority, 
                           levels = c(0, 1, 2, 3),
                           labels = c("General population", 
                                      "Roma", 
                                      "Greek Muslims", 
                                      "Immigrants"))) %>% 
  
  # Convert country1 (whether from Greece or not) to a labelled factor:
  mutate(country1 = factor(country1, 
                           levels = c(1, 0),
                           labels = c("Greece", "Other country"))) %>% 
  
  
  # Label variables with pretty names for the table:
                            ##  variable name = variable label
  labelled::set_variable_labels(vaccrec = "Response status", 
                                age = "Age in years", 
                                gender = "Gender of pupils",
                                urban = "Area type",
                                minority = "Minority group", 
                                country1 = "Country of birth")

```

Using `gtsummary` package to create a descriptive summary table:

```{r s42_representation}

#################################################
# CREATE SUMMARY TABLE BY RESPONSE STATE
#################################################

# Summarise the demographics of the two groups (+/- vaccine book) in a table:
reptable <- vaccine %>% 
  
  # Select subset of demographic variables to include in the summary table:
  dplyr::select(vaccrec, age, gender, urban, minority, country1) %>% 
  
  # Create summary table with gtsummary:
  gtsummary::tbl_summary(
    
    # Stratify by group (no vaccine book = no response, has book = response):
    by = vaccrec, 
    
    # Add summary stats (mean + SD for continuous, proportions for categorical):
    statistic = list(all_continuous() ~ "{mean} ({sd})",
                     all_categorical() ~ "{n} ({p}%)"),
    
    # Exclude NA (missing values) from the table:
    missing = "no") %>% 
  
  # Add tests of statistical significance of differences between groups:
  add_p(test = list(all_continuous() ~ "t.test",       # Continuous variables
                    all_categorical() ~ "chisq.test"), # Categorical variables
        
        # Identify grouping variable:
        group = vaccrec,
                 
        # Define any test arguments that deviate from the default:
        test.args = list(all_tests("t.test") ~ list(var.equal = FALSE), 
                         all_tests("chisq.test") ~ list(simulate.p.value = TRUE))) %>% 
  
  # Add total numbers to column headers:
  add_overall() %>% 
  
  # Add descriptors of the stats presented to row labels:
  add_stat_label() %>% 
  
  # Individually label which row had which statistical test: 
  separate_p_footnotes() %>% 
  
  # Make variable names bold and italics:
  bold_labels() %>% 
  italicize_labels() %>% 
  
  # Tidy up column headers so stats are on second line:
  modify_header(update = list(all_stat_cols(FALSE) ~ "**{level}**\nN = {n}", 
                              stat_0 ~ "**Overall**\nN = {N}")) %>% 
  
  # Convert to flextable to left-align to page margin:
  as_flex_table() %>% 
  
  # Autofit columns to fit headers and content on one line:
  flextable::autofit()
  

#################
# Print results
################

reptable

```


### 4.3: Sampling weights

Calculating sample fraction and sample weights per region:


```{r sample_weights}

###########################################
# CALCULATE SAMPLE FRACTIONS AND WEIGHTS
###########################################

# Import the summary information on the 11 strata (table 4.2):
strata_frame <- rio::import(here::here("data", "Sampling_frames.xlsx"), 
                            which = "table4_2") %>% 
  
  # Add a new column and calculate the sample fractions for each stratum:
  mutate(Sample_fraction = Selected_pupils / Total_pupils) %>% 
  
  # Add a new column and calculate the sample weights for each stratum:
  mutate(Sample_weights = 1 / Sample_fraction)

```


***Table 4.2 -** Per-stratum sampling fractions and sample weights*

```{r s42_sample_weights_tab}

# Show summary in a flextable:
tab42pub <- strata_frame %>% 
  
  # Convert to flextable:
  flextable::qflextable() %>% 
  
  # Autofit column widths to text:
  flextable::autofit()

# Print the table:
tab42pub

```

Finally, we can add the calculated sample weights to the `vaccine` data
set with a `dplyr::left_join()`:

```{r s42_add_sweghts2data}

# Add calculated fraction and weights to vaccine data set:
vaccine <- vaccine %>% 
  
  # Join the fraction and weights from strata_frame to the vaccine data set:
  left_join(y = dplyr::select(.data = strata_frame, # Identify second data set
                              
                              # Identify columns to add:
                              Stratum_id,       # Column to match on in 2nd data
                              Sample_fraction,  # Sample fractions to add to data
                              Sample_weights),  # Sample weights to add to data
            
            # Indicate ID columns to join by:
            by = c("strata" = "Stratum_id"))        



```


### 4.4: Weighted proportions

*A. Preparing the data set:*

First we need to convert the `vaccrec` and `strata` variables to
character class, as this is what the `survey` package expects.

We will also filter on the `vaccrec` variable using `dplyr::filter()`
and selecting only those records where `vaccrec == "Respondents"`.

```{r s44_mmr2_data_prep}

###########################################
# PREPARE AND FILTER THE DATA SET
###########################################

# Create new table of weighted MMR-2 vaccine coverage by strata:
s44data <- vaccine %>% 
  
  # Convert vaccrec and strata to character:
  mutate(vaccrec = as.character(vaccrec), 
         strata = as.character(strata)) %>% 
   
  # Filter for respondents only:
  dplyr::filter(vaccrec == "Respondents") 
  

```

*B. Create the survey design:*

Create a survey design with no clustering, but with weights and strata:

```{r s44_mmr2_survey_design}

# Create the survey design:
s44design <- s44data %>%  

  # Create survey design:
  srvyr::as_survey_design(ids = 1, 
                          weights = Sample_weights, 
                          strata = strata)

```

*C. Calculate weighted proportions (vaccine coverage estimates):*

Calculate vaccine coverage estimates with `sitrep::tab_survey()`:

```{r s44_mmr2_weighted_vce}

# Calculate weighted vaccine coverage for MMR-2:
mmr2cov <- s44design %>% 

  # Create weighted proportions:
  sitrep::tab_survey(mmr2yn,           # The variable to calculate proportions on
                     strata = strata,  # The variable containing the strata
                     keep = c(1),      # The value of interest (mmr2 vaccinated)
                     method = "xlogit",# Log transformation of the mean
                     wide = FALSE,     # Long format better for a lot of strata
                     deff = TRUE,      # Include the design effect in the output
                     pretty = FALSE) %>% # Do not convert to percent (yet)
  
  # Convert strata back to numeric for merging:
  mutate(strata = strtoi(strata))
  

```

*D. Calculate the weighted population fraction:*

Join the vaccine coverage estimates to the table with regional strata and calculate the weighted population fraction:

```{r s44_mmr2_wpopfrac}

###########################################
# CALCULATE TOTAL WEIGHTED VACCINE COVERAGE
###########################################

# Add the results to the strata_frame table:
strata_frame <- strata_frame %>% 
  
  # Add MMR-2 weighted vaccine coverage to strata_frame:
  dplyr::left_join(y = dplyr::select(.data = mmr2cov, 
                                     strata,
                                     proportion, 
                                     proportion_low, 
                                     proportion_upp), 
                   by = c("Stratum_id" = "strata")) %>% 
  
  # Calculate weighted fraction of population:
  mutate(pop_frac = Total_pupils * proportion)

```

*E. Calculate total weighted proportions for the country:*


*Task 4.4 - total weighted vaccination coverage for three strata*

```{r s44_mmr2_twvce_03strata}

################################################
# CALCULATE TOTAL WEIGHTED VACCINATION COVERAGE
################################################

# Calculate total VCE for the first 3 strata:
vc_total_03 <- strata_frame %>% 
  
  # Keep the first three rows:
  slice(1:3) %>% 
  
  # Calculate the percentage:
  summarise(round((sum(pop_frac) / sum(Total_pupils)) * 100, digits = 2)) %>% 
  
  # Get the number out of the data.frame: 
  pull()

# Print the results:
vc_total_03

```

*Task 4.4 - total weighted vaccination coverage for eleven strata*

```{r s44_mmr2_twvce_11strata}

# Calculate total VCE for all 11 strata:
vc_total_11 <- strata_frame %>% 
  
  # Calculate the percentage:
  summarise(round(sum(pop_frac) / sum(Total_pupils) * 100, digits = 2)) %>% 
  
  # Get the number out of the dataframe 
  pull()

# Print the results:
vc_total_11

```

*F. Present per-stratum weighted proportions in a table:*


***Table 4.4 -** Weighted vaccination coverage estimates by region and
area classification, Greece*

```{r s44_mmr2_stratavce_table}
###########################################
# DISPLAY STRATIFIED RESULTS IN A TABLE
###########################################

# Create a pretty flextable of the results:
mmr2pubtable <- strata_frame %>% 
  
  # Convert vaccine coverage estimates and 95% CIs to percent:
  mutate(across(
    .cols = tidyr::starts_with("proportion"), 
    .fns = ~ scales::percent(.x, accuracy = 0.01, suffix = NULL))) %>% 
  
  # Combine 95% CIs in one column:
  tidyr::unite(col = "mmr2_95ci", 
               tidyr::starts_with("proportion_"), 
               sep = " - ", 
               remove = TRUE) %>% 
  
  # Select columns for the final table:
  dplyr::select(1:7, proportion, mmr2_95ci) %>% 
  
  # Reduce Sample fraction to two decimal places for display:
  mutate(across(
    .cols = tidyr::starts_with("Sample_"), 
    .fns = ~ round(.x, digits = 2))) %>% 
  
  # Convert to a flextable:
  flextable::flextable() %>% 
  
  # Add nice theme:
  flextable::theme_booktabs(bold_header = TRUE) %>% 
  
  # Add labels:
  flextable::set_header_labels(values = list(Stratum_id = "Stratum", 
                                             Stratum_name = "Area", 
                                             Area_type = "Type", 
                                             Total_pupils = "Population", 
                                             Selected_pupils = "Surveyed", 
                                             Sample_fraction = "Fraction",                                                     Sample_weights = "Weights", 
                                             proportion = "MMR-2 VCE", 
                                             mmr2_95ci = "95% CI")) %>% 
  
  # Left-align first column (stratum ID):
  flextable::align(j = 1, align = "left", part = "all") %>% 
  
  # Right-align last 2 columns (weighted VCE and 95% CI):
  flextable::align(j = 8:9, align = "right", part = "all") %>% 
  
  # Adjust column widths to fit text:
  flextable::autofit() 
  

#################
# Print results
################

mmr2pubtable


```


### 4.5: Vaccination coverage

**Code for table 4.5.1:**

*A - simple random sampling:*

Create a survey design for simple random sampling (no clustering, weights or strata) and estimate proportions of fully vaccinated individuals:

```{r vce_451_srs}

#####################################
# 01. SIMPLE RANDOM SAMPLING
#####################################

# Use this first result as the base row of table 4.5.1
# Results for the other survey designs can be appended to the same table

# Create new table of full vaccine coverage by (a) simple random sampling:
table451a <- vaccine %>% 
  
  # Convert vaccrec to character:
  mutate(vaccrec = as.character(vaccrec)) %>% 
  
  # Filter for respondents only:
  dplyr::filter(vaccrec == "Respondents") %>% 
  
  # Create survey design for SRS:
  srvyr::as_survey_design(ids = 1,            # No cluster variable
                          weights = NULL,     # No weights
                          strata = NULL) %>%  # No strata
  
  # Create proportions for fully vaccinated:
  sitrep::tab_survey(vacful,           # The variable to calculate proportions on
                     strata = NULL,    # Simple random sampling has no strata
                     keep = c(1),      # The value of interest (fully vaccinated)
                     method = "xlogit",# Use CDC SUDAAN method
                     wide = FALSE,     # Long format better for tabulating results
                     deff = TRUE,      # Include the design effect in the output
                     pretty = FALSE) %>% # Do not merge VCE and 95% CI yet
  
  # Add a design column to describe each survey design:
  mutate(design = "Simple random sampling") %>% 
  
  # Update the design effect where NA to 1 (representing no effect):
  mutate(deff = replace_na(deff, 1))
  
```

*B - Sampling with weights:*

Repeat but this time adding sample weights to the survey design:

```{r vce_451_weights}

#####################################
# 02. SAMPLING WITH WEIGHTS
#####################################

# Create new table of full vaccine coverage by (b) sampling with weights:
table451b <- vaccine %>% 
  
  # Convert vaccrec to character:
  mutate(vaccrec = as.character(vaccrec)) %>% 
  
  # Filter for respondents only:
  dplyr::filter(vaccrec == "Respondents") %>% 
  
  # Create survey design for sampling with weights:
  srvyr::as_survey_design(ids = 1,                  # No clustering
                          weights = Sample_weights, # This time include weights
                          strata = NULL) %>%        # No strata
  
  # Create proportions for fully vaccinated:
  sitrep::tab_survey(vacful,           # The variable to calculate proportions on
                     strata = NULL,    # Weighted sampling has no strata
                     keep = c(1),      # The value of interest (fully vaccinated)
                     na.rm = TRUE,     # Remove missing values
                     wide = FALSE,     # Long format better for a lot of strata
                     deff = TRUE,      # Include the design effect in the output
                     method = "xlogit",# Use CDC SUDAAN method
                     pretty = FALSE) %>% # Do not merge VCE and 95% CI yet
  
  # Add a design column:
  mutate(design = c("Sample weights")) 

```

*C - Sampling with weights and clustering:*

Repeat, now adding sampling weights and clustering by school class to the survey design:

```{r vce_451_clusters}

#######################################
# 03. CLUSTER SAMPLING WITH WEIGHTS
#######################################

# Create new table of full vaccine coverage by (C) cluster sampling with weights:
table451c <- vaccine %>% 
  
  # Convert vaccrec to character:
  mutate(vaccrec = as.character(vaccrec)) %>% 
  
  # Filter for respondents only:
  dplyr::filter(vaccrec == "Respondents") %>% 
  
  # Create survey design for sampling with weights:
  srvyr::as_survey_design(ids = school,              # Clustering by school class
                          weights = Sample_weights,  # Use sampling weights
                          strata = NULL) %>%         # No strata
  
  # Create proportions for fully vaccinated:
  sitrep::tab_survey(vacful,           # The variable to calculate proportions on
                     strata = NULL,    # Weighted sampling has no strata
                     keep = c(1),      # The value of interest (fully vaccinated)
                     wide = FALSE,     # Long format better for a lot of strata
                     deff = TRUE,      # Include the design effect in the output
                     method = "xlogit",# Use CDC SUDAAN method
                     pretty = FALSE) %>% # Do not merge VCE and 95% CI yet
  
  # Add a design column:
  mutate(design = c("Sample weights + clusters")) 

```

*D - Cluster sampling with weights and strata:*

Repeat again, this time using a survey design that has clustering, weights and strata:

```{r vce_451_strata}

#########################################
# 04. CLUSTER SAMPLING, WEIGHTS & STRATA
#########################################

# Create table of full vaccine coverage by (d) cluster sampling, weights & strata:
table451d <- vaccine %>% 
  
  # Convert vaccrec to character:
  mutate(vaccrec = as.character(vaccrec)) %>% 
  
  # Convert strata to character:
  mutate(strata = as.character(strata)) %>% 
  
  # Filter for respondents only:
  dplyr::filter(vaccrec == "Respondents") %>% 
  
  # Create survey design for sampling with weights, clusters & strata:
  srvyr::as_survey_design(ids = school,             # Cluster by school class
                          weights = Sample_weights, # Include sample weights
                          strata = strata) %>%      # Include strata
  
  # Create proportions for fully vaccinated:
  sitrep::tab_survey(vacful,           # The variable to calculate proportions on
                     strata = NULL,    # To get the total we will leave this NULL
                     keep = c(1),      # The value of interest (fully vaccinated)
                     wide = FALSE,     # Long format better for a lot of strata
                     deff = TRUE,      # Include the design effect in the output
                     method = "xlogit",# Use CDC SUDAAN method
                     pretty = FALSE) %>% # Do not merge VCE and 95% CI yet
  
  # Add a design column:
  mutate(design = c("Sample weights + clusters + strata")) 

```



***Table 4.5.1 -** Vaccination coverage estimates with different survey
designs*

```{r vce_451_printab}

# Bind results together in one table:
table451 <- dplyr::bind_rows(table451a, # VCE with Simple random sampling 
                             table451b, # VCE with weights
                             table451c, # VCE with weights + clustering
                             table451d) # VCE with weights + clustering + strata


# Create publishable table of results:
table451pub <- table451 %>% 
  
  # Now we can convert the estimates and 95% CI to percentages:
  mutate(
    across(
      # for each column which has proportion in the name
      contains("proportion"), 
      # convert to a percentage
      ~ scales::percent(.x, accuracy = 0.01))) %>% 
  
  # And finally we can trim the decimal places for other columns:
  mutate(deff = round(deff, digits = 2)) %>% 
  
  # Create merged column for 95% CIs: 
  tidyr::unite(
    # name the new column CI95
    col = "CI95",
    # state which two columns to combine
    proportion_low, proportion_upp, 
    # separate the values with a dash 
    sep = " - ", 
    # drop the old columns
    remove = TRUE
    ) %>% 
  
  # Select the columns to print:
  dplyr::select(design, 
                deff, 
                n, 
                proportion, 
                CI95) %>% 
  
  # Lastly we can convert it to a flextable for printing:
  flextable::qflextable() %>% 
  
  # Add labels:
  flextable::set_header_labels(values = list(design = "Survey design", 
                                             deff = "Design effect",
                                             n = "VCE (n)", 
                                             proportion = "VCE (%)", 
                                             CI95 = "95% CI")) %>% 
  
  # Right-align last 2 columns (weighted VCE and 95% CI):
  flextable::align(j = 4:5, align = "right", part = "all") %>% 

  # Adjust column widths to fit text:
  flextable::autofit()
  

##################
# Print results
#################

table451pub

```


*E - Estimating the intra-class correlation coefficient:*

Calculate intra-cluster correlation coefficient (rho) with design effect of 2.36 and mean class (cluster) size of 20:

```{r calc_icc_b}

# Calculate ICC:
study_rho <- (2.36 - 1) / (20 - 1)

# Print result:
study_rho

```


**Code for table 4.5.2**

First, create the survey design, with clustering, weights and strata:


```{r finaltab_design}

vce_design <- vaccine %>% 
  
  # Convert vaccrec to character:
  mutate(vaccrec = as.character(vaccrec)) %>% 
  
  # Convert strata to character:
  mutate(strata = as.character(strata)) %>% 
  
  # Filter for respondents only:
  dplyr::filter(vaccrec == "Respondents") %>% 
  
    # Create survey design for sampling with weights, clusters & strata:
  srvyr::as_survey_design(ids = school, 
                          weights = Sample_weights, 
                          strata = strata) 

```

Next, estimate vaccine coverage for DTP3 stratified by minority group and urban/rural area of residence, using `purrr::map()` to iterate over the two stratifiers:

```{r finaltab_dtp3stratified}

#############################################
# Estimate VC for DTP3 by minority and urban:
#############################################


restab452a <- purrr::map(
  # for each of the variables listed
  .x = c("minority", "urban"), 
  # run the following function (replacing x with each variable one-by-one)
  .f = function(x) {
    
    # using the study design object 
    vce_design %>% 
      # Create proportions for DTP3 stratified by the current variable being run:
      sitrep::tab_survey(dtp3yn, 
                         # purrr replaces x with "minority" and then with "urban"
                         # x is in curly brackets so it is interpreted as a 
                         # variable name instead of a character
                         strata = {x},  
                         keep = c(1),
                         na.rm = TRUE,
                         method = "xlogit",
                         wide = FALSE,     
                         deff = TRUE,      
                         pretty = FALSE) %>% 
      
      # Rename minority column to stratum:
      # Note that here we dont need curly brackets 
      # (because we want it to be a character)
      rename(stratum = x) %>%
      
      # Remove row with missing values:
      filter(!is.na(stratum))
  }
) %>% 
  ## pull the results out of lists and in to a single dataframe
  bind_rows()

```

Use `purrr::map()` again to iterate through all the other vaccine variables and estimate vaccine coverage for each of them:

```{r finaltab_vaccines_overall}

# Create a list of variables (vaccines) to estimate vaccine coverage with:
varlist <- c("dtp4yn", 
             "dtp5yn", 
             "mmr1yn", 
             "mmr2yn",
             "hibprmyn", 
             "hibfulyn", 
             "hbv3yn", 
             "mnc1yn", 
             "pne1yn", 
             "var1yn")


restab452b <- purrr::map(
  # for each of the variables listed
  .x = varlist, 
  # run the following function (replacing x with each variable one-by-one)
  .f = function(x) {
    
    vce_design %>% 
      # purrr replaces x with each of the vaccines listed
        # x is in curly brackets so it is interpreted as a 
        # variable name instead of a character
      sitrep::tab_survey({x},           
                         strata = NULL,  
                         keep = c(1),
                         na.rm = TRUE,
                         method = "xlogit",
                         wide = FALSE,     
                         deff = TRUE,      
                         pretty = FALSE) %>% 
      
      # Create stratum column:
    mutate(stratum = "Overall")
  }
) %>% 
  bind_rows()

```

Estimate full vaccine coverage (vaccine completeness), stratified by minority group and urban rural areas of residence:

```{r finaltab_completeness}


restab452c <- purrr::map(
  .x = c("minority", "urban"), 
  .f = function(x) {
    
    vce_design %>%
      sitrep::tab_survey(vacful, 
                         # purrr replaces x with "minority" and then with "urban"
                         # x is in curly brackets so it is interpreted as a 
                         # variable name instead of a character
                         strata = {x},  
                         keep = c(1),
                         na.rm = TRUE,
                         method = "xlogit",
                         wide = FALSE,     
                         deff = TRUE,      
                         pretty = FALSE) %>% 
      
      # Rename minority column to stratum:
      rename(stratum = x)  %>% 
  
      # Remove row with missing values:
      filter(!is.na(stratum))
  }
) %>% 
  bind_rows()

```

Estimate proportions of children who received timely vaccination, stratified by minority group and urban rural area of residence:

```{r finaltab_timeliness}

restab452d <- purrr::map(
  .x = c("minority", "urban"), 
  .f = function(x) {
    
    vce_design %>% 
      sitrep::tab_survey(vactime, 
                         # purrr replaces x with "minority" and then with "urban"
                         # x is in curly brackets so it is interpreted as a 
                         # variable name instead of a character
                         strata = {x},  
                         keep = c(1),
                         na.rm = TRUE,
                         method = "xlogit",
                         wide = FALSE,     
                         deff = TRUE,      
                         pretty = FALSE) %>% 
      
      # Rename minority column to stratum:
      rename(stratum = x) %>%
      
      # Remove row with missing values:
      filter(!is.na(stratum))
  }
) %>% 
  bind_rows()

```


***Table 4.5.2 -** Vaccination coverage estimates stratified by
population sub-groups*

```{r finaltab_printable}

# combine each of the result tables in to one
restabpub <- bind_rows(restab452a, 
                       restab452b,
                       restab452c,
                       restab452d
                       ) %>% 
  # to be able to ignore the value column (which only contains 1s)
  ungroup()


# Create publishable table of results:
restabpub <- restabpub %>% 
  
  # Now we can convert the estimates and 95% CI to percentages:
  mutate(
    across(
      # for each column which has proportion in the name
      contains("proportion"), 
      # convert to a percentage
      ~ scales::percent(.x, accuracy = 0.01))) %>%
  
  # And finally we can trim the decimal places for other columns:
  mutate(across(c(n, deff), 
                ~ round(.x, digits = 2))) %>% 
  
  # Create merged column for 95% CIs: 
  tidyr::unite(
    # name the new column CI95
    col = "CI95",
    # state which two columns to combine
    proportion_low, proportion_upp, 
    # separate the values with a dash 
    sep = " - ", 
    # drop the old columns
    remove = TRUE
    ) %>% 
  
  # Select the columns to print:
  dplyr::select(variable,
                stratum,
                deff, 
                n, 
                proportion, 
                CI95) %>% 
  
  # Recode variable names to nice labels for printing (see data dictionary):
  mutate(variable = dplyr::recode(variable, 
                                  dtp3yn = "DTP: 3 doses", 
                                  dtp4yn = "DTP: 4 doses", 
                                  dtp5yn = "DTP: 5 doses", 
                                  mmr1yn = "MMR: 1 dose", 
                                  mmr2yn = "MMR: 2 doses", 
                                  hibprmyn = "HiB: partial", 
                                  hibfulyn = "HiB: full", 
                                  hbv3yn = "HBV: 3 doses", 
                                  mnc1yn = "Men C: 1 dose", 
                                  pne1yn = "Pneumo: 1 dose", 
                                  var1yn = "Varicella: 1 dose", 
                                  vacful = "Fully vaccinated", 
                                  vactime = "Timely vaccination")) %>% 
  
  # Lastly we can convert it to a flextable for printing:
  flextable::qflextable() %>% 
  
  # Merge cells in the vaccine colum as the values are repeated:
  flextable::merge_v(j = c("variable"), target = c("variable")) %>% 

  # Add labels:
  flextable::set_header_labels(values = list(variable = "Vaccine",
                                             stratum = "Stratum",
                                             deff = "Design effect",
                                             n = "VCE (n)", 
                                             proportion = "VCE (%)", 
                                             CI95 = "95% CI")) %>% 
  
  # Right-align last 2 columns (weighted VCE and 95% CI):
  flextable::align(j = 5:6, align = "right", part = "all") %>% 
  
  # Add borders under the merged cells:
  flextable::hline(i = rle(cumsum(.$body$spans$columns[,1] ))$values,
                   border = fp_border(style = "solid", width = 1)) %>% 
  
  # Fix thickness of bottom border:
  fix_border_issues() %>% 
  
  # Add bottom border back:
  flextable::hline_bottom(border = fp_border(style = "solid", width = 2), 
                          part = "body") %>% 
  
  # Adjust column widths to fit text:
  flextable::autofit()

#################
# Print results
################

restabpub

```


## S5: Modelling Prevalence Ratios:

### 5.1: Descriptive analysis


*A - Data import and preparation*

Import the data set, convert variables of interest to factors, reorder factor levels:

```{r s5_data_prep}

############################################################
# 02. IMPORT DATA, CONVERT TO FACTORS, LABEL & ORDER LEVELS
############################################################

# Import vaccine5.dta:
vaccine <- rio::import(here::here("data", "vaccine5.dta"))  %>% 
  
  # Convert minority to a labelled factor:
  mutate(minority = factor(minority, 
                           levels = c(0, 1, 2, 3),
                           labels = c("General population", 
                                      "Roma", 
                                      "Greek Muslims", 
                                      "Immigrants"))) %>% 
 
  # Create new categorical variable (agegroup) from mother's age:
  mutate(magegroup = case_when(
    
    # Logical criteria      Label 
    mage < 25               ~ "Under 25", 
    between(mage, 25, 29)   ~ "25 - 29",
    mage >= 30              ~ "30 or over")) %>% 
  
  # Convert to a factor and put the age groups in ascending order:
  mutate(magegroup = forcats::fct_relevel(magegroup, 
                                          "Under 25", 
                                          "25 - 29", 
                                          "30 or over")) %>% 
  
  # Create new categorical variable for number of siblings:
  mutate(nsibcat = case_when(
    
    # Logical criteria      Label
    osib1 >= 3              ~ "3 or more",
    between(osib1, 1, 2)    ~ "1 - 2", 
    osib1 == 0              ~ "No siblings")) %>% 
  
  # Convert to a factor and put the categories in descending order:
  mutate(nsibcat = forcats::fct_relevel(nsibcat, 
                                        "3 or more", 
                                        "1 - 2", 
                                        "No siblings")) %>% 
  
  # Convert school (numeric IDs) to a factor:
  mutate(school = factor(school)) %>% 
  
  # Create a labeled factor from educf for father's education:
  mutate(educf = factor(educf, 
                           levels = c(2, 3, 4, 6),
                           labels = c("Grammar school (< 9 years)", 
                                      "High school (9 - 11 years)", 
                                      "College (12 years)", 
                                      "University (> 12 years)"))) %>% 
  
  # Create labelled factor for a1posg (balanced positive opinion, 3 categories):
  mutate(a1posg = factor(a1posg, 
                         levels = c(0, 1, 2), 
                         labels = c("No positive opinion", 
                                    "Moderate positive opinion", 
                                    "Strong positive opinion")))

```

*04. Bulk processing: reclassifying a list of variables as factors*

Create lists of variables to loop over and give them nice human-readable labels:

```{r s5_varlists}

#############################
# 01. CREATE VARIABLE LISTS
#############################

# First we create a list of binary variables to label:
binary_vars <- c("a1posyn",
                 "uncritical", 
                 "a1x1g", 
                 "a1x2g", 
                 "a1x5g", 
                 "a3x1g", 
                 "a3x2g", 
                 "a3x5g")

# Now iterate through the list of binary variables to convert them to factors:
vaccine <- vaccine %>% 
  # Mutate across list of binary variables to convert all to labelled factors:
  mutate(across(
    .cols = c(all_of(binary_vars)),    # Columns to loop through: all binary_vars
    .fns = ~factor(.x,                 # Function to apply: convert to factor 
      levels = c(0, 1),                # Stipulate levels from existing values
      labels = c("no", "yes"))))       # Label levels as no and yes


# Next, create a list of all variables to analyse:
allvars <- c("minority", 
             "magegroup", 
             "educf",
             "nsibcat", 
             "a1posg", 
             binary_vars)

# Create a list of nice labels for allvars:
allvarlabs <- c("Minority group", 
                "Mother's age at childbirth", 
                "Father's education",
                "Number of siblings",
                "Balanced positive opinion on vaccination: likhert",
                "Balanced positive opinion on vaccination: binary",
                "Uncritical positive opinion on vaccination",
                "Vaccination is necessary for my child",
                "Vaccines may harm my child",
                "Natural disease preferable to vaccines",
                "Long distance to immunization site",
                "Inconvenient opening hours",
                "Cost of vaccines")

# Create a dataframe of original variable names and labels to use in recoding: 
recoders <- cbind(allvars, allvarlabs)

```

*B - Survey design*

Create the survey design, including clustering by school class, weights, and strata as before:

```{r s5_survey_design}

vce_design <- vaccine %>% 
  
  # Create survey design:
  srvyr::as_survey_design(ids = school,      # This is the cluster variable
                          weights = weight,  # These are the sample weights
                          strata = strata)   # These are the 11 strata

```

*C - Estimate stratified proportions:*

Calculate descriptive statistics (proportions) for minority group, mother's age group and number of other siblings, applying the survey design:

```{r s5_estimate_props}

# Create a list of variables:
varlist <- c("minority", 
             "magegroup", 
             "nsibcat")

# Loop over the variables:
restab452a <- purrr::map(
  
  # For each of the variables listed:
  .x = varlist, 
  
  # Run the following function 
  # (replacing x with each variable one-by-one)
  .f = function(x) {
    
    # Apply the study design:
    vce_design %>% 
      
      # purrr replaces x with each of the variables listed
      # x is in curly brackets so it is interpreted as a 
      # variable name instead of a character
      sitrep::tab_survey({x},           
                         strata = NULL,  
                         keep = TRUE,
                         na.rm = TRUE,
                         method = "xlogit",
                         wide = FALSE,     
                         deff = TRUE,      
                         pretty = FALSE) 
  }

) %>% 
  bind_rows()

```

*D - create summary table of results*

***Table 5.1 -** Counts and proportions of parental characteristics adjusted by survey design*

```{r s5_pubtable51}

# Create publishable table of results:
restabpub <- restab452a %>% 
  
  # Now we can convert the estimates and 95% CI to percentages:
  mutate(across(contains("proportion"), ~ scales::percent(.x, accuracy = 0.01))) %>%
  
  # And finally we can trim the decimal places for other columns:
  mutate(across(c(n, deff), ~ round(.x, digits = 2))) %>% 
  
  # Create merged column for 95% CIs: 
  tidyr::unite(col = "CI95", 
               proportion_low, proportion_upp, 
               sep = " - ", 
               remove = TRUE) %>% 
  
  # Add nice names for stratifier variables to the table:
  mutate(variable = case_when(
    variable == "minority"   ~ "Minority group", 
    variable == "magegroup"  ~ "Mother's age at childbirth",
    variable == "nsibcat"    ~ "Number of other siblings")) %>% 
  
  # Select the columns to print:
  dplyr::select(variable,
                value,
                deff, 
                n, 
                proportion, 
                CI95) %>% 
  
  # Lastly we can convert it to a flextable for printing:
  flextable::qflextable() %>% 
  
  # Merge cells in the stratifier colum as the values are repeated:
  flextable::merge_v(j = "variable", target = "variable") %>% 
  
  # Add labels:
  flextable::set_header_labels(values = list(variable = "Stratifier",
                                             value = "Stratum",
                                             deff = "Design effect",
                                             n = "VCE (n)", 
                                             proportion = "VCE (%)", 
                                             CI95 = "95% CI")) %>% 
  
  # Right-align last 2 columns (weighted VCE and 95% CI):
  flextable::align(j = 5:6, align = "right", part = "all") %>% 

  # Add borders under the merged cells:
  flextable::hline(i = rle(cumsum(.$body$spans$columns[,1] ))$values, 
                   border = fp_border(style = "solid", width = 1)) %>% 
  
  # Add bottom border back:
  flextable::hline_bottom(border = fp_border(style = "solid", 
                                             width = 2), 
                            part = "body") %>% 
  
  # Fix thickness of bottom border:
  fix_border_issues() %>% 
  
  # Adjust column widths to fit text:
  flextable::autofit()



################
# Print results
###############

restabpub
  
```


### 5.2: Crude associations

*A - Counts of fully vaccinated children:*

Use `sitrep::tab_linelist()` to generate cross-tabulated counts of fully vaccinated children (`vacful`) for all the variables in the `allvars` list created earlier:

```{r s52_counts}

restab52a <- vaccine %>% 
  
  # Filter for those that are fully vaccinated only:
  dplyr::filter(vacful == 1) %>% 
  
  # Create summary table:
  sitrep::tab_linelist(all_of(allvars)) %>%
  
  # Drop un-weighted proportions variable 
  # (we will add weighted proportions later)
  dplyr::select(-proportion) %>%
  
  # We can use our dataframe of labels to recode the variable column
  # Note the quotations to define which variables in recoders to use
  # you could also simply remove these as the default recodes from col 1 to 2
  mutate(variable = matchmaker::match_vec(variable, 
                                          dictionary = recoders,
                                          from = "allvars", to = "allvarlabs")) 
  
```

*B - Vaccination coverage stratified by parental characteristics and beliefs:*

Estimate vaccination coverage with `vacful`, stratifying by each of the variables in the `allvars` list and using `purrr::map()` to loop through them:

```{r s52_vce}

#################################
# 01. Calculate VCE proportions:
#################################

restab_vce <- purrr::map(
  
  # allvars is the list of variables to loop through that we already created:
  .x = allvars, 
  .f = function(x) {
    
    vce_design %>% 
      
      # VCE will be calculated for vacful
      sitrep::tab_survey(vacful,
                         # Each variable in allvars is a stratum
                         strata = all_of({x}),
                         # We are only interested in vacful == 1
                         keep = c(1),           
                         na.rm = TRUE,
                         method = "xlogit",
                         wide = FALSE,     
                         deff = TRUE,      
                         pretty = FALSE) %>% 
      
      # Rename factor level column to value:
      dplyr::rename(response = x) %>%
      
      # Remove rows with missing values:
      filter(!is.na(response)) %>% 
      
      # Add the variable name to make merging more accurate: 
      mutate(variable = x)

    }

  ) %>% 
  
  # Bind the results from each variable into a data.frame:
  bind_rows() %>% 
  
  # Remove value = 1 grouping (from vacful == 1)
  ungroup %>% 
  
  # Trim the decimal places for other columns:
  mutate(across(c(n, deff), 
                ~ round(.x, digits = 2))) %>% 

  # Convert the estimates and 95% CI to percentages:
  mutate(across(contains("proportion"),             
                ~ scales::percent(.x,                  # Cols to convert to %
                          accuracy = 0.1,      # No. decimal places
                          suffix = ""))) %>%   # Do not add % sign
  
  # Create merged column for 95% CIs: 
  tidyr::unite(col = "CI95",                     # Name of new column in quotes
               proportion_low, proportion_upp,   # Two columns to combine
               sep = " - ",                      # Separator between values
               remove = TRUE) %>%                # Remove old columns
  
  # Rename proportion column to avoid confusion when merging tables:
  dplyr::rename(vce_prop = proportion) %>% 
  
  # Add human readable labels to variable column:
  mutate(variable = matchmaker::match_vec(variable, recoders))  %>% 
  
  # Select the columns to keep:
  dplyr::select(variable,         # Variable name from allvars (to group)
                value = response, # Rename to match restab52a (to group)
                deff,             # Design effect for reference
                n,                # Estimated count for reference
                vce_prop,         # VCE (%) to add to table
                CI95)             # VCE 95% CIs for reference


```

Now we can bind the first two tables together:

```{r s52_count_vce_bind}

# Join vaccine coverage to counts table:
restab52b <- restab52a %>% 
  
  # Merge the two tables with a left join on variable and response:
  left_join(y = dplyr::select(.data = restab_vce, 
                              variable, 
                              value,
                              vce_prop), 
            
            # Join by both variable and value
            # This is safer than value alone 
            # as yes/no answers are not unique
            by = c("variable", "value")) %>%

  # Add brackets around vaccine coverage estimate proportion:
  # note variables are between curly brackets {} within double quotation marks
  mutate(vce_prop = stringr::str_glue("({vce_prop})")) %>%
  
  # Create combined count and estimated vaccine coverage column:
  tidyr::unite(col = "n_vce", 
               n, vce_prop, 
               sep = " ", 
               remove = TRUE)
  
```

*D - Crude vaccination prevalence ratios by parental characteristics and beliefs:*

Create a Poisson model with robust error variance to calculate prevalence ratios for full vaccination coverage (`vacful`) by minority group using `fixest::feglm()`:

***Table 5.2.1 -** Vaccination prevalence ratio by minority group*

```{r poisson_crude_singlevar}

# Create the model:
model1 <- fixest::feglm(fml = vacful ~ minority,         # Model formula
                        family = poisson(link = "log"),  # Model type
                        vcov = hetero ~ school,          # SE method & cluster
                        data = vaccine)                  # Data set

# View a summary of the results:
fixest::etable(model1)

# Use the broom.mixed package to extract prevalence ratios and 95% CI:
model1tab <- broom.mixed::tidy(x = model1,
                               conf.int = TRUE, 
                               conf.method = "Wald") %>% 
  
  # Exponentiate estimate and 95% CIs:
  mutate(across(
    .cols = c(estimate, starts_with("conf.")),
    .fns = exp)) %>% 
  
  # Round up numeric columns to 2 decimal places:
  mutate(across(
    .cols = where(is.numeric), 
    .fns = round, digits = 2)) %>% 
  
  # Convert to flextable for printing:
  flextable::qflextable()

# View the results:
model1tab

```


Repeat the prevalence ratio calculation as above, for each of the variables in `allvars` by creating a function that will apply the same `fixest::feglm()` parameters and take a list of variables to loop over as input:

```{r poisson_crude_function}

# Function to create Poisson fixed effects model with robust errors:
poisson_tabulator <- function(predictor) {
  
  # Construct model formula:
  pm_formula = as.formula(stringr::str_glue("vacful ~ {predictor}"))

  # Construct the poisson model clustering by school with robust errors:
  modtab = fixest::feglm(fml = pm_formula, 
                         family = poisson(link = "log"),
                         vcov = hetero ~ school, 
                         data = vaccine) %>% 
    
    # Extract the results in a table:
    broom.mixed::tidy(conf.int = TRUE, 
                      conf.method = "Wald") %>% 
    
    # Exponentiate estimate and 95% CIs:
    mutate(across(
      .cols = c(estimate, starts_with("conf.")),
      .fns = exp)) %>% 
    
    # Round up numeric columns to 2 decimal places:
    mutate(across(
      .cols = where(is.numeric), 
      .fns = round, digits = 2)) %>% 
    
    # Merge lower and upper 95% CI in a new column:
    tidyr::unite(col = "95% CI", 
                 starts_with("conf."), 
                 sep = " - ", 
                 remove = TRUE) %>% 

    # Remove intercept:
    dplyr::filter(term != "(Intercept)") 
    
  # Return the results table:
  return(modtab)

}  

```

Apply the function to `allvars` using `purrr::map()`.

Split the variable and factor level names into two separate columns with the help of functions from the `stringr` package:

```{r poisson_crude_allvars}

# Apply the model to the list of variables called 'allvars':
poiscrudetab <- allvars %>% 
  
  # Loop them through the 'poison_tabulator' function we just created:
  purrr::map(poisson_tabulator) %>% 
  
  # Bind the results into a single table:
  bind_rows() %>% 
  
  # Split term into two columns (variable name and level / value):
  dplyr::mutate(
    
    # Create variable col (strings in 'term' that match any of allvars):
    variable = stringr::str_extract(term, 
                                    str_c(allvars, collapse = "|")), 
    # Create value col (whats left after strings matching allvars are removed):
    value = stringr::str_remove(term, 
                                str_c(allvars, collapse = "|"))) %>% 
    
    # Add human readable labels to values in the variable column:
    mutate(variable = matchmaker::match_vec(variable, recoders)) %>% 

    # Remove unnecessary columns:
    dplyr::select(-term, -std.error, -statistic) %>% 
  
    # Reorder new columns:
    relocate(c(variable, value), .before = estimate) %>%
  
    # Put estimate with 95% CI:
    relocate(p.value, .before = estimate) 

```


***Table 5.2.2 -** Vaccination prevalence ratios by parental characteristics and beliefs*

```{r poisson_crude_allvars_table}


poiscrudetabpub <- poiscrudetab %>% 
  
  # Convert to a flextable:
  flextable::qflextable() %>%
  
  # Merge cells in the vaccine colum as the values are repeated:
  flextable::merge_v(j = c("variable"), target = c("variable")) %>% 

  # Label column headers:
  flextable::set_header_labels(values = list(
    variable = "Parameter",
    value = "Characteristic", 
    p.value = "P value", 
    estimate = "Prevalence ratio",
    `95% CI` = "95% CI")) %>% 

  # Right align numeric results columns:
  flextable::align(j = 3:5, 
                   align = "right", 
                   part = "all") %>%
  
  # Add highlighting of significant values:
  flextable::bg(i = ~ p.value < 0.05, 
                j = 3:5,
                bg = "yellow") %>% 
  
  # Add border lines under the merged cells:
  flextable::hline(i = rle(cumsum(.$body$spans$columns[,1] ))$values, 
                   border = fp_border(style = "solid", width = 1)) %>% 
  
  # Fix thickness of bottom border:
  fix_border_issues() %>% 
  
  # Add bottom border back:
  flextable::hline_bottom(border = fp_border(style = "solid", width = 2), 
                          part = "body") %>% 
  
  # Adjust column widths to fit text:
  flextable::autofit() 


##################
# Print the table:
poiscrudetabpub

```

Merge crude prevalence ratios with counts and vaccine coverage estimates into one table:

```{r s52_combined_results_table}

#######################################
# Subsetting Poisson results for merge:
#######################################

# Subset the necessary columns to merge:
poiscrudetabmini <- poiscrudetab %>% 
  
  # Combine prevalence ratios and 95% CIs in one column:
  mutate(pr_95 = str_glue("{estimate} ({`95% CI`})")) %>% 
  
  # Remove unnecessary columns:
  dplyr::select(-estimate, -`95% CI`, -p.value)


###############################################
# Merge vaccine coverage and prevalence ratios:
###############################################

# Merge the two tables with a left join on variable and value columns:
restab52c <- restab52b %>% 
  
  # Join the counts / vaccine coverage table to the poisson table on response:
  left_join(y = dplyr::select(.data = poiscrudetabmini,

                              # Columns to include:
                              variable,
                              value,
                              pr_95),
            
            # Join by variable and value to ensure unique matches:
            by = c("variable", "value")) %>% 
  
  # Encode the missing values for intercepts as 'ref'
  # Otherwise leave the rest of the values as they are:
  mutate(pr_95 = tidyr::replace_na(pr_95, "ref"))

```

*E - Crude odds ratios* *for vaccination by parental characteristics and beliefs (optional exercise)*

Create a similar function to set parameters for `fixest::feglm()`, this time to calculate odds ratios.  As before, this function will facilitate looping through all the variables in `allvars` in the next step:

```{r s52_or_function}

##############################################
# 01. Function to tabulate crude odds ratios
#############################################

# Function to create Poisson fixed effects model with robust errors:
or_tabulator <- function(predictor) {
  
  # Construct model formula:
  pm_formula = as.formula(str_glue("vacful ~ {predictor}"))

  # Construct the poisson model clustering by school with robust errors:
  modtab = fixest::feglm(fml = pm_formula, 
                         family = binomial(link = "logit"),
                         vcov = hetero ~ school, 
                         data = vaccine) %>% 
    
    # Extract the results in a table:
    broom.mixed::tidy(conf.int = TRUE, 
                      conf.method = "Wald") %>% 
    
    # Exponentiate estimate and 95% CIs:
    mutate(across(
      .cols = c(estimate, starts_with("conf.")),
      .fns = exp)) %>% 
    
    # Round up numeric columns to 2 decimal places:
    mutate(across(
      .cols = where(is.numeric), 
      .fns = round, digits = 2)) %>% 
    
    # Merge lower and upper 95% CI in a new column:
    tidyr::unite(col = "95% CI", 
                 starts_with("conf."), 
                 sep = " - ", 
                 remove = TRUE) %>% 

    # Remove intercept:
    dplyr::filter(term != "(Intercept)") 
    
  # Return the results table:
  return(modtab)

}  

```

Now we can apply the `or_tabulator` function to `allvars` :

```{r or_crude_allvars}

# Apply the model to the list of variables called 'allvars':
orcrudetab <- allvars %>% 
  
  # Loop them through the 'poison_tabulator' function we just created:
  purrr::map(or_tabulator) %>% 
  
  # Bind the results into a single table:
  bind_rows() %>% 
  
  # Split term into two columns (variable name and level / value):
  dplyr::mutate(
    
    # Create variable col (strings in 'term' that match any of allvars):
    variable = stringr::str_extract(term, 
                                    str_c(allvars, collapse = "|")), 
    # Create value col (whats left after strings matching allvars are removed):
    value = stringr::str_remove(term, 
                                str_c(allvars, collapse = "|"))) %>% 
    
    # Add human readable labels to values in the variable column:
    mutate(variable = matchmaker::match_vec(variable, recoders)) %>% 

    # Remove unnecessary columns:
    dplyr::select(-term, -std.error, -statistic) %>% 
  
    # Reorder new columns:
    relocate(c(variable, value), .before = estimate) %>%
  
    # Put estimate with 95% CI:
    relocate(p.value, .before = estimate) 

```

We can merge the crude odds ratios with the table that now contains vaccination coverage and prevalence ratios:

```{r s52_combined_results_with_or}

#######################################
# Subsetting Poisson results for merge:
#######################################

# Subset the necessary columns to merge:
orcrudetabmini <- orcrudetab %>% 
  
  # Combine odds ratios and 95% CIs in one column:
  mutate(or_95 = str_glue("{estimate} ({`95% CI`})")) %>% 
  
  # Remove unnecessary columns:
  dplyr::select(-estimate, -`95% CI`, -p.value)


###############################################
# Merge vaccine coverage and prevalence ratios:
###############################################

# Merge the two tables with a left join on variable and value columns:
restab52d <- restab52c %>% 
  
  # Join the counts / vaccine coverage table to the poisson table on response:
  left_join(y = dplyr::select(.data = orcrudetabmini,

                              # Columns to include:
                              variable,
                              value,
                              or_95),
            
            # Join by variable and value to ensure unique matches:
            by = c("variable", "value")) %>% 
  
  # Encode the missing values for intercepts as 'ref'
  # Otherwise leave the rest of the values as they are:
  mutate(or_95 = tidyr::replace_na(or_95, "ref"))

```


***Table 5.2.3 -** Crude measures of association between vaccination and
parental characteristics*

```{r s52_crude_final_table}


crudefinaltabpub <- restab52d %>% 
  
  # Convert to a flextable:
  flextable::qflextable() %>%
  
  # Merge cells in the vaccine colum as the values are repeated:
  flextable::merge_v(j = c("variable"), target = c("variable")) %>% 

  # Label column headers:
  flextable::set_header_labels(values = list(
    variable = "Parameter",
    value = "Characteristic", 
    n_vce = "N (VCE)", 
    pr_95 = "Prevalence ratio (95% CI)",
    or_95 = "Odds ratio (95% CI)")) %>% 

  # Right align numeric results columns:
  flextable::align(j = 3:5, 
                   align = "right", 
                   part = "all") %>%
  
  # Add borders under the merged cells:
  flextable::hline(i = rle(cumsum(.$body$spans$columns[,1] ))$values, 
                   border = fp_border(style = "solid", width = 1)) %>% 
  
  # Fix thickness of bottom border:
  fix_border_issues() %>% 
  
  # Add bottom border back:
  flextable::hline_bottom(border = fp_border(style = "solid", width = 2), 
                          part = "body") %>% 
  
  # Adjust column widths to fit text:
  flextable::autofit()


##################
# Print the table:
crudefinaltabpub

```


### 5.3: Adjusted associations


Change the order of the `minority` variable so that `Roma` comes first and can be used as the reference level, with `forcats::fct_relelevel()` as shown below:

```{r s53_change_ref_minority}

# Using the vaccine data:
vaccine <- vaccine %>% 
  
  # Change the order of the factor levels so Gen Pop comes last
  # This will make Roma the first level:
  dplyr::mutate(minority = forcats::fct_relevel(.f = minority, 
                                                "General population",
                                                after = Inf))

```

Use `fixest::feglm()` to create a Poisson model with robust error variance and calculate adjusted prevalence ratios, using all the variables in `allvars` as fixed effects and `school` as the cluster variable:

```{r s53_adj_poisson_model}

# Create the Poisson model with robust error variance:
modelres <- vaccine %>% 
  
  # Create fixed effects poisson model clustering by school:
  fixest::feglm(fml = vacful ~ .[allvars],
                family = poisson(link = "log"),
                vcov = hetero ~ school)

```

If you wish to inspect the co-linearity scores, you can do this by viewing the `$collin.var` element of the model results:

```{r s53_adj_poisson_model_colinearity}

# View which elements of the model have been determined to be colinear:
modelres$collin.var

# View the colinearity coefficients for each element of the model:
modelres$collin.coef

# View a summary of the model results:
fixest::etable(modelres)

```

We can now extract the model results and put them in a table, using `broom.mixed::tidy()` as before:

```{r s53_adj_poisson_model_table}

# Extract the model results into a table:
modeltab <- modelres %>% 

  # Extract the results in a table:
  broom.mixed::tidy(conf.int = TRUE, 
                    conf.method = "Wald") %>% 
  
  # Exponentiate the estimates and 95% CI to convert to prevalence ratios:
  dplyr::mutate(across(c(estimate, starts_with("conf.")), exp)) %>% 
  
  # Remove intercept (estimate for reference values):
  dplyr::filter(term != "(Intercept)") %>% 
  
  # Split term into two columns (variable name and level / value):
  dplyr::mutate(
    # Create variable col (strings in 'term' that match any of allvars):
    variable = stringr::str_extract(term, 
                                    str_c(allvars, collapse = "|")), 
    # Create value col (whats left after strings matching allvars are removed):
    value = stringr::str_remove(term, 
                                str_c(allvars, collapse = "|"))) %>% 
  
  # Round to 2 decimal places in numeric columns:
  mutate(across(
    .cols = where(is.numeric), 
    .fns = round, digits = 2)) %>% 

  # Merge lower and upper 95% CI in a new column:
  tidyr::unite(col = "95% CI", 
               starts_with("conf."), 
               sep = " - ", 
               remove = TRUE) %>% 
  
  # Remove unnecessary columns:
  dplyr::select(-term, -std.error, -statistic) %>% 
  
  # Reorder new columns:
  relocate(c(variable, value), .before = estimate) %>%
  
  # Put estimate with 95% CI:
  relocate(p.value, .before = estimate)

```

Use e.g. `first(levels(vaccine$minority)` to get the reference values for each variable in `allvars` so that you can add them to the results table.  Loop over all the variables in `allvars` by using `summarise(across(allvars, …))`, then add the reference values to the table with a `left_join()`: 

```{r s53_extract_ref_levels}

# Extract reference levels for all the variables in allvars:
reflevels <- vaccine %>% 
  
  # Get first level of each factor in allvars:
  summarise(across(.cols = all_of(allvars),                 # Use columns in allvars
                   .fns = ~ first(levels(.x)))) %>% # Get first factor level
  
  # Transpose the results:
  pivot_longer(cols = everything(),   # Transpose all columns from previous step
               names_to = "variable", # Put the variable names in col 'variable'
               values_to = "reference") # Put the ref values in col 'reference'


###############################

# Merge reference values with model results table:
modeltab <- modeltab %>% 
  
  # Join the reference values to modeltab:
  left_join(y = reflevels, 
            by = "variable") %>% 
  
  # Move the new reference column:
  relocate(reference, .before = value) %>% 
  
  # Add more human readable labels to the variable column:
  mutate(variable = matchmaker::match_vec(variable, recoders)) 

```

Create the final results table and highlight elements with significant P values:

***Table 5.3 -** Adjusted measures of association between vaccination status & parental characteristics*

```{r s53_adj_poisson_model_pubtable}

modeltabpub <- modeltab %>% 

  # Convert to a flextable:
  flextable::qflextable() %>%
  
  # Merge cells in the vaccine colum as the values are repeated:
  flextable::merge_v(j = c("variable"), target = c("variable", "reference")) %>% 

  # Label column headers:
    flextable::set_header_labels(values = list(
      variable = "Parameter",
      reference = "Reference level",
      value = "Characteristic", 
      p.value = "P value (Wald)", 
      estimate = "Prevalence ratio",
      `95% CI` = "95% CI")) %>% 

  # Right align numeric results columns:
  flextable::align(j = 4:6, align = "right", part = "all") %>%
  
  # Add highlighting of significant values:
  flextable::bg(i = ~ p.value < 0.05, 
                j = 4:6,
                bg = "yellow") %>% 
  
  # Add borders under the merged cells:
  flextable::hline(i = rle(cumsum(.$body$spans$columns[,1] ))$values,
                   border = fp_border(style = "solid", width = 1)) %>% 
  
  # Fix thickness of bottom border:
  fix_border_issues() %>% 
  
  # Add bottom border back:
  flextable::hline_bottom(border = fp_border(style = "solid", width = 2), 
                          part = "body") %>% 
  
  # Adjust column widths to fit text:
  flextable::autofit()



###############
# Print table:
##############

modeltabpub

```


