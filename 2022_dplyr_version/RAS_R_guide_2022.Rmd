---
title: "RAS Case study in R" 
subtitle: "Childhood vaccination coverage survey in Greece, 2006"
author: "Amy Mikhail and Alexander Spina (Applied Epi)"
date: "Date revised: 27 May 2022"
output:
  html_document:
    code_folding: hide
    toc: true
    toc_float:
      toc_collapsed: true
    toc_depth: 3
  pdf_document:
    toc: true
    toc_depth: 3
  word_document:
    toc: true
    toc_depth: 3
theme: sandstone
geometry: margin = 1.5cm
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      eval = TRUE,
                      results = 'hide', 
                      message = FALSE, 
                      warning = FALSE)
```

**Contributing authors and version history:**

This case study was originally written by the following authors:

-   Kostas Danis
-   Dimitris Papamichail
-   Takis Panagiotopoulos

An R companion guide for the computer practicals accompanying the case
study was developed in 2017 by:

-   Patrick Keating
-   Alexander Spina
-   Alexandre Blake

This was updated in 2018 by:

-   Ashley Sharpe

Further updates were made in 2022, to replace base R code with more
modern functions from `tidyverse` packages and to add an alternative
mixed-methods based approach for section 6 following discussions with
the module organizers, by:

-   Amy Mikhail
-   Alexander Spina

All copyrights and licenses of the original document apply here as well.

\newpage

# Introduction to the R companion guide

This guide is an R companion guide to the main case study document.
Participants are advised to follow the case study sections in the main
document to read the background information for each task, and refer to
this document for every exercise that requires some analysis to be
performed. For convenience, the questions for each analysis task have
also been reprinted here.

Note that this guide has been updated to use readily available and
currently maintained R packages. As such, there may be some minor
differences in approach or results when compared to STATA. To read more
about the methods underlying each R function, see the relevant help
file, e.g. `?package::function`.

## Prerequisites

Participants are expected to be familiar with data management and basic
analysis in R and RStudio. It is advisable to have up-to-date versions
of both softwares installed. The code in this guide was updated and
tested using:

-   R version 4.1.3 (2022-03-10)
-   RStudio version 2022.02.0 Build 443

## R packages

This guide uses packages from the `tidyverse` which are being used more
and more for data analysis, due to their easy to read and efficient
coding syntax. The approach for setting up an RStudio project, importing
and cleaning data and managing code, as well as creating summary tables
and graphs follows that presented in the [Epidemiologist R
handbook](https://epirhandbook.com/en/) (click on the link to access
it).

The packages required for this case study can be installed by running
the code below. This code has also been made available as a separate R
script. It uses the `pload()` function from the `pacman` package as this
will check the user's library for required packages, install them if
they are missing, and then load them into the current R session. This
code should therefore be rerun at the beginning of each session, to
ensure that all the required libraries are loaded.

```{r packages, results='hide', message=FALSE, warning=FALSE}

# Packages to install *before* running pacman pload():
#####################################################

# Ensures the package "pacman" is installed
if (!require("pacman")) install.packages("pacman")

# Ensure the package "remotes" is installed
if (!require("remotes")) install.packages("remotes")

# Install the epikit package from Github:
if (!require("epikit")) remotes::install_github("R4EPI/epikit")

# Install the sitrep package from Github:
if (!require("sitrep")) remotes::install_github("R4EPI/sitrep")


# Install and/or load required packages:
########################################
pacman::p_load(
  
  # Project and file management
  #############################
  here,      # file paths relative to R project root folder
  rio,       # import/export of many types of data
  rmarkdown, # reading and printing RAS R markdown guide
  knitr,     # reading and printing RAS R markdown guide
  
  # Package install and management
  ################################
  pacman,   # package install/load
  remotes,  # install from github
  
  # General data management
  #########################
  tidyverse,   # includes many packages for tidy data wrangling:
  #dplyr,      # data management
  #tidyr,      # data management
  #ggplot2,    # data visualization
  #stringr,    # work with strings and characters
  #forcats,    # work with factors 
  #lubridate,  # work with dates
  #purrr       # iteration and working with lists
  janitor,     # data cleaning
  
  # Summary tables:
  #########################
  flextable,   # Creating printable summary tables
  officer,     # Fine tuning flextables
  gtsummary,   # making descriptive and statistical tables
  smd,         # Helper functions for gtsummary tables
  expss,       # Labelling variables and values
  scales,      # helper functions
  
  # RAS analysis:
  #########################
  pps,         # Probability proportional to size (PPS) sampling
  sampler,     # Calculate sample size
  srvyr,       # Create survey design and calculate vaccination coverage
  survey,      # Support for srvyr functions
  Hmisc        # Summary functions
)

# Check for and install Github packages:
pacman::p_load_gh(
  
  # Packages for survey analysis and mixed effects:
  #################################################
  "R4EPI/epikit",      # Functions for survey analysis
  "R4EPI/sitrep"      # Function wrappers for survey analysis
)

```

\newpage

## Data management

**File organisation:**

The R practical material for this case study is stored in a folder
called `rvcs_2022`. Please download this folder from EVA and save it on
your computer.

There is an R project file (`.Rproj`) in this folder and we suggest you
begin this practical session by double clicking on this file to open it.

You can then create a new R script called `vcsurvey.R` and save it in
the `rvcs_2022` folder.

The data sets have been stored in a sub-folder called `data`.

Note that the relative file paths used for importing data in this guide
assume the above folder structure.

**Importing data sets:**

The data sets can be easily imported using the `import()` function from
the `rio` package, combined with the `here` package to construct
relative file paths.

Most of the data sets are STATA `.dta` files, while one file for the
first exercise is a Microsoft Excel workbook. Both file types can be
read in to R using `rio::import()` and specifying the relevant
arguments.

\newpage

# Guidance and code for practical sessions

In the sections below, you will find a brief background and description
for each task, followed by an explanation of how to complete the task
using R, that highlights suggested packages and functions. This is then
complemented by some example code.

The example code has been presented in full, so that you can reference
it when undertaking similar analyses with your own data in future. If
you are working from the HTML version of this document, the code will
initially remain hidden, so that you can attempt to write your analysis
script using just the R coding tips as a guide if you wish. To reveal
the code, click on the `code` button that appears at the top of each
coding section.

Notes:

-   Only the tasks which require data manipulation or analysis in R are
    reprinted below

-   Begin with the main case study guide and refer to this R companion
    when a task is introduced that requires computational analysis.

-   To undertake the practical tasks, you will need to create your own R
    script and either write your own code (using the R coding tips in
    this document and package help files as a guide) or copy the example
    code into your script and run it, to see the results.

\newpage

## Session 1: Sampling frames

### Task 1.2 - stratified proportional sampling

**Background:**

In the main guide, you have been provided with the background and aims
of this case study, which is to undertake a vaccination coverage survey
in school children in Greece. A two-step stratified proportional cluster
sampling strategy has been selected. Your first task is to calculate the
number of classes to sample in each region and rural / urban stratum:

**Task instructions:**

Using the data provided in table 1.2 below (which can be imported into R
from the `table1_2` worksheet of the `Sampling_frames.xlsx` Microsoft
Excel workbook in the `data` sub-folder):

1.  Within each region, calculate the number of clusters (school
    classes) to sample from;

2.  Calculate the number of classes for each urban / rural stratum
    relative to the population size;

3.  Aim to include 50 school classes from each region;

4.  Assume that all school classes have an equal number of students;

5.  Complete table 1.2 in the main case study guide with your results
    (percentage and number of classes to sample for each urban and rural
    stratum in each of the 6 regions).

| Region                 |  Urban |  Rural |  TOTAL |
|------------------------|-------:|-------:|-------:|
| Thraki                 |  11624 |   6884 |  18508 |
| Macedonia-Thessalia    | 116322 |  47101 | 163423 |
| Ipeiros-Ionian Islands |  11446 |  15449 |  26895 |
| Peloponissos-Sterea    |  55770 |  44132 |  99902 |
| Attiki                 | 174493 |   1667 | 176160 |
| Crete-Aegean Islands   |  36374 |  24752 |  61126 |
| **TOTAL**              | 406029 | 139985 | 546014 |

: Table 1.2 - Number of children aged 5 - 9 years in Greece by region
and urban/rural area

**R coding tips:**

First, import the summary data from table 1.2.

This table is currently in wide format, but to calculate the number of
classes to sample from in each strata, it needs to be converted to long
format (i.e. 'tidy data') so that a single column defines the strata
(urban or rural) and another column contains the population for each
stratum. We can do this with the `tidyr::pivot_longer()` function.

We can then calculate the relative proportions in each stratum and from
there determine the number of school classes to sample (out of 50) for
each stratum within each region:

```{r sframe_import}

# Import sample frame for regions:
regions <- rio::import(here::here(file = "data", "Sampling_frames.xlsx"),
                         which = "table1_2")

# Create new table for results:
rsf_long <- regions %>% 
  
  # Convert table to tidy data:
  tidyr::pivot_longer(cols = c(Urban, Rural),        # Convert to tidy format
                      names_to = "Stratum",          # Store strata in new col
                      values_to = "Population") %>%  # Store population in new col
  
  # Calculate proportions and number of classes to sample:
  mutate(Proportion = Population/Total,              # Calculate proportions
         Nclasses = round(50*Proportion, digits = 0))# Calculate number of classes

  

```

\newpage

### Task 1.3 - simple random sampling

**Background:**

Table 1.3 is part of the sampling frame for the stratum "rural areas of
the region of Peloponissos-Sterea", where all schools have only one
first grade school-class.

**Task instructions:**

1.  Generate a simple random sample of 22 school classes using random
    number selection;

2.  Identify the selected school classes in the sampling frame (table
    1.3);

3.  Calculate the sampling fraction.

**R coding tips:**

The sampling frame (list of school classes in the Peleponissos-Sterea
region) can be imported from the `Sampling_frames.xlsx` workbook
(`table1_3` is the name of the worksheet).

The simple random sample of 22 classes can then be identified using the
`dplyr` convenience function `slice_sample()` to return a random subset
of 22 rows of the original sampling frame.

```{r simple_random_sample}

# Import the sampling frame of school classes in Peleponissos-Sterea:
class_frame <- rio::import(here::here(file = "data", "Sampling_frames.xlsx"),
                         which = "table1_3")


# Perform a simple random sample to select 22 classes from the list:
class_list <- class_frame %>% 
  
  # Subset the simple random sample of 22 classes:
  slice_sample(n = 22) %>% 
  
  # Arrange results in ascending order by ID:
  dplyr::arrange(ID)

```

The sampling fraction is the number of units sampled divided by the
total number of units in the sampling frame, i.e.:

```{r sample_fraction}

# Calculate the sampling fraction for this example:
sample_fraction <- round(22/nrow(class_frame), digits = 2)

```

\newpage

### Task 1.4 - systematic sampling

**Background:**

Systematic sampling is similar to simple random sampling except that the
total sampling frame is divided by the desired number of sampling units
to select and every *nth* row of the sampling frame is selected
according to the result. This can be useful when subjects are being
prospectively recruited to a study, when the total size of the sampling
frame is not yet clear or when it is necessary to ensure consistent
sampling over multiple days with an unknown number of subjects recruited
per day.

**Task instructions:**

1.  Use the same sampling frame as for the previous section
    (`class_frame`);

2.  Divide the total number of classes in the sampling frame by the
    desired number of units to sample (22) to calculate the group size;

3.  Randomly select one number *n* from this group size;

4.  Select every *nth* row of the sampling frame to produce the
    systematic sample;

5.  Limit the number of returned rows to the desired number of units to
    sample (22).

**R coding tips:**

After calculating the size of the groups to divide the sampling frame
into, we can select a random number from this group size using the base
R function `sample.int()`.

Note that you can ensure you always get the same number back by using
the `set.seed()` function - this way if you send your script to someone
else they would be able to reproduce the same sample.

This random number can then be fed into the `dplyr::slice()` command as
shown below to select every *nth* row of the sampling frame. Note that
if *n* is small / an early number in the sequence, an excess of rows may
be selected. If this happens, the returned rows can be limited to the
desired sample size by using the `dplyr::slice_head()` function:

```{r systematic_sample}

# Define the sampling interval - the n to systematically sample 
# (i.e. every nth row to choose):
sample_n <- as.integer(nrow(class_frame)/22)

# Calculate the random starting point for systematic sampling:
sample_start <- sample.int(n = sample_n, size = 1)

# Define rows systematically (every nth row) to filter the sampling frame: 
sample_rows <- seq.int(sample_start, nrow(class_frame), sample_n)

# Now subset the sampling frame and filter for every nth row:
class_system <- class_frame %>% 
  
  # Select every nth row from the sampling frame:
  slice(sample_rows) %>% 
  
  # Limit the number of returned rows to the desired sample size (22)
  slice_head(n = 22)
  
```

\newpage

### Task 1.5 - Probability Proportional to Size sampling

**Background:**

The researchers originally chose to use school classes as the sampling
units, because it was assumed that all classes had similar numbers of
students. An alternative sampling unit would be the schools themselves;
however unlike for classes, the number of students in each school varies
widely.

Probability proportional to size (PPS) sampling is a method that takes
varying sample sizes in the sample units into account. This helps to
avoid under-representing one subgroup in a study and yields more
accurate results.

In this case study, you have been provided with a list of schools in
urban areas of Attiki, which also indicates the number of grade 1
students in each school and the number of classes. This data set can be
imported from the `table1_5` worksheet in the `Sampling_frames.xlsx`
workbook. Schools can be selected adjusting for the size of the student
population, by performing PPS sampling. The column containing the number
of students in each school is used as input.

**Task instructions:**

1.  Use the sampling frame for Attiki schools in urban areas presented
    in `table1_5`

2.  Select 12 schools by probability proportional to size sampling
    *without replacement*

3.  Indicate which schools have been selected in table 1.5 in the main
    case study guide

**R coding tips:**

There are several packages available on CRAN that can perform PPS
sampling. In the example code below, we will use the `sampford()`
function from the `pps` package to perform the sampling without
replacement, which uses the classic method developed by [Sampford
(1967)](https://academic.oup.com/biomet/article-abstract/54/3-4/499/230469?redirectedFrom=fulltext).

We can use the indices in the results to filter the sampling frame for
the 12 selected schools (using `dplyr::slice()` as above).

Note that an alternative would be to use `dplyr::slice_sample()` and
supply probabilities for each school to the `weight_by` argument. To do
this you would have to calculate probabilities for each school:
`school_frame %>% mutate(probability = Students / sum(Students))`.

We opted for using the `pps::sampford()` function, as the documentation
on methods is more transparent.

```{r pps_sample}

# Import the sampling frame of urban schools with grade 1 classes in Attiki:
school_frame <- rio::import(here::here(file = "data", "Sampling_frames.xlsx"), 
                            which = "table1_5")

# Perform PPS sampling to select 12 schools:
schools2survey <- school_frame %>% 
  
  # Select schools by PPS without replacement:
  slice(pps::sampford(size = Students, n = 12))

```

\newpage

## Session 2 - sample size calculations

### Task 2.1 - sample size for single proportion

**Background:**

For each region, a sampling frame has been returned indicating the total
number of students in the target class / age group. The sampling frame
sizes by region are shown in table 2.1 below.

The researchers now need to calculate sample sizes for each region,
given the parameters described below:

-   Vaccination coverage in previous surveys exceeded 85% for most
    vaccines;

-   Sample sizes will be calculated with a target precision of +/- 4% ;

-   The response rate from previous surveys was approximately 87.5%.

| Region                     | Number of pupils (sampling frame) |
|----------------------------|----------------------------------:|
| Thraki                     |                              4201 |
| Macedonia-Thessalia        |                             31045 |
| Ipeiros-Ionian Islands     |                              5055 |
| Peloponnisos-Sterea Ellada |                             17741 |
| Attiki                     |                             30586 |
| Kriti-Aegean Islands       |                             12218 |
| **Greece (total)**         |                            100846 |

: Table 2.1 - Total number of pupils recorded in the sampling frame, by
region.

**Task description:**

1.  Calculate the single proportion sample size required for each
    region, assuming simple random sampling;

2.  Use the per region student population, previous vaccination coverage
    estimate and the desired precision presented above in the
    calculations;

3.  Adjust the calculations to take into account the lower response rate
    (87.5%) achieved in previous surveys.

**R coding tips:**

The sampling frame sizes by region in table 2.1 can be imported into R
from the `table2_1` worksheet in the `Sampling_frames.xlsx` workbook.

To calculate sample size, we can use the `sampler` package. In the first
instance, the `rsampcalc()` function can be used for each region. The
arguments correspond to the inputs above as follows:

-   *N* = population (i.e. number of students in each region from table
    2.1)

-   *e* = tolerable margin of error (i.e. desired precision of +/- 4%)

-   *ci* = confidence interval (i.e. 95% - the default value)

-   *p* = anticipated response distribution (convert 85% vaccination
    coverage to proportion i.e. 0.85)

-   *over* = desired over-sampling proportion (convert 87.5% response to
    inverse proportion i.e. 1 - 0.875)

Note that the last argument, `over` can be used to increase the sample
size in order to compensate for a low response rate, by taking the
inverse proportion of the response rate from previous surveys (1 -
0.875) and adding this to the calculated sample size as a buffer.

To first have a look at the sample sizes without this buffer, leave this
argument on its default setting (0).

```{r sample_size_basic}

# Import the sampling frame of urban schools with grade 1 classes in Attiki:
region_frame <- rio::import(here::here(file = "data", "Sampling_frames.xlsx"), 
                            which = "table2_1")

# Calculate sample size (number of students to survey) for each region:
region_frame <- region_frame %>% 
  
  # Calculate baseline sample size for each region:
  mutate(Sample_basic = sampler::rsampcalc(N = Student_pop, 
                                          e = 4, 
                                          ci = 95, 
                                          p = 0.85, 
                                          over = 0)) %>% 
  
  # Calculate sample size with adjustment for response rate of 87.5%:
  mutate(Sample_rradjust = sampler::rsampcalc(N = Student_pop, 
                                          e = 4, 
                                          ci = 95, 
                                          p = 0.85, 
                                          over = 1 - 0.875))

```

\newpage

### Task 2.2 - sample size calculation with design effect

**Background:**

The researchers have identified that there is likely to be variance
between school classes and between students within classes, and want to
take this into account in the sample size calculations using the design
effect. To calculate the design effect, they have provided the following
information:

-   *rho* (intra-cluster correlation coefficient): 0.05

-   mean class size: 20 students

**Task description:**

1.  Use *rho* and mean class size provided above to calculate the design
    effect;

2.  Adjust the sample sizes calculated in task 2.1 to account for the
    design effect;

3.  Calculate the total number of clusters required using the adjusted
    sample size.

**R coding tips:**

The design effect can be calculated in R using mathematical operators
with a simple formula:

$$
deff = 1 + (n - 1) \times rho
$$

where:

$deff$ is the design effect;

$n$ is the average number of subjects per cluster (e.g. mean number of
students per class);

$rho$ is the intra-cluster correlation coefficient (e.g. rate of
homogeneity for vaccination status).

The calculated design effect can then be multiplied by the original
sample size per region to adjust it. The adjusted sample sizes can be
added to a new column in the `region_frame` table that you created in
the previous task.

The number of clusters required can then be estimated by dividing the
total sample size (sum of number of students to survey in the 6 regions)
by the average cluster (class) size (20).

```{r sample_size_icc}

# Calculate the design effect given n = 20 and rho = 0.05:
deff <- 1 + (20 - 1) * 0.05

# Add new rho-adjusted sample size calculation to the table:
region_frame <- region_frame %>% 
  
  # Calculate sample size with adjustment for the design effect:
  mutate(Sample_rhoadjust = round(Sample_rradjust * deff, digits = 0))

# Calculate the number of clusters (school classes) required:
nclusters <- round((sum(region_frame$Sample_rhoadjust)) / 20, digits = 0)

```

\newpage

## Session 4 - descriptive analysis

### Tasks 4.1 & 4.2 - Sample representation

**Background:**

In this section, you will assess how well represented the target
population is among surveyed students, using key demographic variables
such as age, sex and classification of residence area type. The data
have been provided in the file `vaccine4.dta`.

**Task description:**

1.  Identify demographic variables of interest to compare in the data
    set (see data dictionary, annex 5 and 6 in the main case study
    guide);

2.  Summarize key demographic variables for respondents and
    non-respondents;

3.  Perform a statistical test to determine if any of these key
    demographic variables are differently distributed in respondents and
    non-respondents;

4.  Consider what kind of bias could have been introduced due to
    non-response (not having a vaccine book)?

5.  How would you interpret the results in the summary table in light of
    that limitation?

**R coding tips:**

Comparing the demographics of surveyed to non-surveyed students would
require access to basic information for the whole sampling frame. The
`vaccine4.dta` data only contains data for sampled students, but we can
check for any differences between those that did (respondents) and
didn't (non-respondents) have a vaccine book, to demonstrate the
principles involved (subjects who did not have a vaccine book were
excluded from subsequent analyses). This is encoded in the `vaccrec`
variable.

Before starting, you may wish to explore the data. Using the
`dplyr::describe()` command as well as the information in the data
dictionary (annex 5 and 6) will give you an overview of the data set.

The following demographic variables may be useful to include in the
summary table:

-   *vaccrec* - vaccine book received (no / non-respondent = 0, yes /
    respondent = 1)

-   *gender* - gender of the participants (0 = female, 1 = male)

-   *age* - age of the participants in years (with decimals)

-   *urban* - whether the participants are resident in an urban (1) or
    rural (0) area.

-   *minority* - ethnic grouping of the participants

-   *country1* - country or birth (levels are Other country (0) or
    Greece (1) )

The `gtsummary::tbl_summary()` function can be used to directly create a
comparative summary of gender, age, urban residence, minority group and
country of birth, stratified by receipt of a vaccine book (re-labelled
as `Non-respondent` for those that did not have a vaccine book and
`Respondent` for those that did have a vaccine book). The code below
shows you how to create `table 4.1` from the `vaccine4.dta` data set.

Statistical differences between respondents and non-respondents can be
assessed with a `t.test()` for continuous variables (such as age) and
`prop.test()` or `chisq.test()` for categorical variables (such as
gender).

You can use the results of these tests to determine if the respondents
are sufficiently representative of the whole population in the sampling
frame, or if there is a bias in this group that needs to be taken into
account.

The code below constructs the summary table in two steps:

1.  Import the data and add nice display labels to the variables of
    interest with `dplyr` and `expss` ;

2.  Create the summary table and compute statistics with the `gtsummary`
    package.

Note that in some cases it is necessary to explicitly state that a
function is from a particular package using the
`packagename::function()` syntax, as there are other packages that have
functions with the same name but different arguments, that we also have
loaded in this R session (see for example `dplyr::select()` below).

```{r representation}

#################################################
# IMPORT DATA, LABEL VARIABLES AND FACTOR LEVELS
#################################################

# Import the vaccine coverage study data for session 4:
vaccine <- rio::import(here::here(file = "data", "vaccine4.dta"))  %>% 
  
  # Convert vaccrec to a factor and add nice display labels:
  mutate(vaccrec = factor(vaccrec, 
                          levels = c(0, 1), 
                          labels = c("Non-respondents", "Respondents"))) %>% 
  
  # Convert gender to a labelled factor:
  mutate(gender = factor(gender,
                         levels = c(0, 1),
                         labels = c("Female", "Male"))) %>% 
  
  # Convert residence area type to a labelled factor:
  mutate(urban = factor(urban, 
                        levels = c(0, 1),
                        labels = c("Rural", "Urban"))) %>% 

  
  # Convert minority to a factor and add nice display labels:
  mutate(minority = factor(minority, 
                           levels = c(0, 1, 2, 3),
                           labels = c("General population", 
                                      "Roma", 
                                      "Greek Muslims", 
                                      "Immigrants"))) %>% 
  
  # Convert country1 (whether from Greece or not) to a labelled factor:
  mutate(country1 = factor(country1, 
                           levels = c(1, 0),
                           labels = c("Greece", "Other country"))) %>% 
  
  
  # Label variables with pretty names for table:
  labelled::set_variable_labels(
                      ## variable name = variable label 
                      vaccrec = "Response status", 
                      age = "Age in years", 
                      gender = "Gender of pupils",
                      urban = "Area type",
                      minority = "Minority group", 
                      country1 = "Country of birth")


#################################################
# CREATE SUMMARY TABLE BY RESPONSE STATE
#################################################

# Summarise the demographics of the two groups (+/- vaccine book) in a table:
reptable <- vaccine %>% 
  
  # Select subset of demographic variables for comparison:
  dplyr::select(vaccrec, age, gender, urban, minority, country1) %>% 
  
  # Create summary table with gtsummary:
  gtsummary::tbl_summary(
    
    # Stratify by group (no vaccine book = excluded, has book = included):
    by = vaccrec, 
    
    # Add summary stats (mean + SD for continuous, proportions for categorical):
    statistic = list(all_continuous() ~ "{mean} ({sd})",
                     all_categorical() ~ "{n} ({p}%)"),
    
    # Exclude NA (missing values) from the table:
    missing = "no") %>% 
  
  # Add tests of statistical significance of differences between groups:
  add_p(test = list(all_continuous() ~ "t.test", 
                    all_categorical() ~ "chisq.test"), 
        
        # Identify grouping variable:
        group = vaccrec,
                 
        # Define any test arguments that deviate from the default:
        test.args = list(all_tests("t.test") ~ list(var.equal = FALSE), 
                         all_tests("chisq.test") ~ list(simulate.p.value = TRUE))) %>% 
  
  # Add total numbers to column headers:
  add_overall() %>% 
  
  # Add descriptors of the stats presented to row labels:
  add_stat_label() %>% 
  
  # individually label which row had which statistical test: 
  separate_p_footnotes() %>% 
  
  # Make variable names bold and italics:
  bold_labels() %>% 
  italicize_labels() %>% 
  
  # Tidy up column headers so stats are on second line:
  # the reason this is dense is because the overall column is a stat column but has no defined levels
  ## note if creating word doc you will need to use \n instead of <br> for line break
  modify_header(
    update = list(all_stat_cols(FALSE) ~ "**{level}**<br>N = {n}",
                  stat_0 ~ "**Overall**<br>N = {N}"))

```

\newpage

### Task 4.3 - Sampling weights

As mentioned earlier, the following sampling strategy was chosen: The
country was stratified into six regions, which, apart from the capital
region (Attica), were further subdivided into urban and rural areas, to
create 11 strata (`strata`). In each region school classes (clusters =
`school`) were randomly selected with probability proportional to the
total number of first year grammar school pupils. The sampling frame of
all school classrooms in the country for the academic year 2004-2005,
was obtained from the Greek Ministry of Education. The list contained
108 538 pupils from both public and private schools.

**Task description:**

Using the information on the 11 strata in `table 4.2` :

1.  Calculate the sampling fraction for each stratum;

2.  Calculate the sampling weight for each stratum.

**R coding tips:**

Table 4.2 can be imported into R from the `table4_2` worksheet in the
`Sampling_frames.xlsx` workbook. This table contains the names, IDs and
urban / rural status of the 11 strata, along with the total student
population from the sampling frame and the number of students selected
in each stratum.

The sampling fraction and weights can easily be calculated and added in
two new columns to the imported table with `dplyr` using the formulas
below.

The sampling fraction is given by:

$$
Sample fraction = \frac{n}{N}
$$

The sampling weights are the inverse of the sample fraction:

$$
Weight = \frac{1}{(\frac{n}{N})}
$$

```{r sample_weights}

###########################################
# CALCULATE SAMPLE FRACTIONS AND WEIGHTS
###########################################

# Import the summary information on the 11 strata (table 4.2):
strata_frame <- rio::import(here::here(file = "data", "Sampling_frames.xlsx"), 
                            which = "table4_2") %>% 
  
  # Add a new column and calculate the sample fractions for each stratum:
  mutate(Sample_fraction = Selected_pupils / Total_pupils) %>% 
  
  # Add a new column and calculate the sample weights for each stratum:
  mutate(Sample_weights = 1 / Sample_fraction)


###########################################
# MERGE WITH VACCINE DATA SET
###########################################

# Add calculated fraction and weights to vaccine data set:
vaccine <- vaccine %>% 
  
  # Join the fraction and weights from strata_frame to the vaccine data set:
  left_join(y = dplyr::select(.data = strata_frame, # Identify second data set
                              
                              # Identify columns to add:
                              Stratum_id,           
                              Sample_fraction, 
                              Sample_weights),
            
            # Indicate ID columns to join by:
            by = c("strata" = "Stratum_id"))        

```

\newpage

### Task 4.4 - Weighted vaccination coverage

**Background:**

The researchers now want to use the sample weights you calculated in the
previous section to estimate MMR-2 vaccination coverage in each stratum
and subsequently in the whole country.

**Task description:**

1.  First, restrict the data set to respondents (`vaccrec == 1` )

2.  Calculate the weighted vaccination coverage for each of the 11
    strata

3.  Calculate the total vaccination coverage for the first three strata

4.  Calculate the total vaccination coverage for the whole country (all
    11 strata)

**R coding tips:**

The data set can be restricted to respondents by filtering for
`vaccrec == 1` . The variable containing MMR2 vaccination status of
respondents is called `mmr2yn`.

To calculate the weighted vaccination coverage, you can use the
`Sample_weights` variable that was created in the previous task and
apply this to the `mmr2yn` variable by `strata`.

You will first need to set up a stratified survey design, which can be
achieved with the `srvyr` package `as_survey_design()` function. This
takes the following arguments:

-   *ids* - this is for the variable containing cluster IDs - in this
    case we will not use it and set to 1[^1]

-   *weights* - enter the name of the `Sample_weights` variable here

-   *strata* - enter the name of the variable containing the `strata`
    here

[^1]: Although the researchers did have clusters in their survey design
    (school classes), for simplicity you have just been given the
    sampling frames (population and number of pupils selected) for the
    11 strata (urban and rural areas in each of the 6 regions).
    Therefore, you can undertake this task as if there were only strata
    and no clusters in the design.

You can then apply this survey design object to the `tab_survey()`
function from the `sitrep` package, which will calculate the weighted
proportions, as shown below. Note that the `sitrep` package is not yet
available on CRAN, but it can be installed from Github (see package
install section). For other ways to calculate weighted proportions, have
a look at the [Survey
chapter](<https://epirhandbook.com/en/survey-analysis.html>) in the
Epidemiologist R handbook.

To calculate the total weighted vaccine coverage:

1.  First multiply the weighted proportions you just calculated by the
    population in each stratum. You can do this more easily by adding
    the weighted proportions to the `strata_frame` table you were
    working with in the previous task, by using a `dplyr::left_join()`
    and creating a new column with `mutate` to hold the result.

2.  Next, calculate the sum of the product of the weighted proportions
    and per-stratum population.

3.  Finally, divide the result by the sum of the per-stratum
    populations.

You will need to do this initially for the first three strata only, and
then for all 11 strata to work out the total weighted vaccination
coverage estimate.

In the last section, we have demonstrated how to tidy up and present a
subset of the variables in the `strata_frame` table for publication,
using the `flextable` package. This creates a table object which can be
saved to a Microsoft word document and edited in MS word later, if
desired.

```{r mmr2_weighted_coverage}

###########################################
# CALCULATE MMR2 PROPORTIONS BY STRATA
###########################################

# Create new table of weighted MMR-2 vaccine coverage by strata:
mmr2cov <- vaccine %>% 
  
  # Convert vaccrec to character:
  mutate(vaccrec = as.character(vaccrec), 
         # Convert strata to character:
         strata = as.character(strata)) %>% 
   
  # Filter for respondents only:
  dplyr::filter(vaccrec == "Respondents") %>% 
  
  # Create survey design:
  srvyr::as_survey_design(ids = 1, 
                          weights = Sample_weights, 
                          strata = strata) %>% 
  
  # Create weighted proportions:
  sitrep::tab_survey(mmr2yn,           # The variable to calculate proportions on
                     strata = strata,  # The variable containing the strata
                     keep = c(1),      # The value of interest (mmr2 vaccinated)
                     wide = FALSE,     # Long format better for a lot of strata
                     deff = TRUE,      # Include the design effect in the output
                     pretty = FALSE) %>% # Do not convert to percent (yet)
  
  # Convert strata back to numeric for merging:
  mutate(strata = strtoi(strata))
  
###########################################
# CALCULATE TOTAL WEIGHTED VACCINE COVERAGE
###########################################

# Add the results to the strata_frame table:
strata_frame <- strata_frame %>% 
  
  # Add MMR-2 weighted vaccine coverage to strata_frame:
  dplyr::left_join(y = dplyr::select(.data = mmr2cov, 
                                     strata,
                                     proportion, 
                                     proportion_low, 
                                     proportion_upp), 
                   by = c("Stratum_id" = "strata")) %>% 
  
  # Calculate weighted fraction of population:
  mutate(pop_frac = Total_pupils * proportion)

# Calculate the total vaccination coverage estimate for the first 3 strata:
vc_total_03 <- strata_frame %>% 
  # keep the first three rows
  slice(1:3) %>% 
  # calculate the percentage
  summarise(
    round(sum(pop_frac) / sum(Total_pupils) * 100, digits = 2)
  ) %>% 
  # get the number out of the dataframe 
  pull()


# Calculate the total vaccination coverage estimate for all 11 strata:
vc_total_11 <- strata_frame %>% 
  # calculate the percentage
  summarise(
    round(sum(pop_frac) / sum(Total_pupils) * 100, digits = 2)
  ) %>% 
  # get the number out of the dataframe 
  pull()

###########################################
# DISPLAY STRATIFIED RESULTS IN A TABLE
###########################################

# Create a pretty flextable of the results:
mmr2pubtable <- strata_frame %>% 
  
  # Create summary display column of vaccine coverage:
  mutate(mmr2_wvce = percent(proportion, accuracy = 0.01)) %>% 
  
  # Add 95% confidence intervals:
  mutate(mmr2_95ci = paste0("[", 
                            percent(proportion_low, accuracy = 0.01), 
                            " - ", 
                            percent(proportion_upp, accuracy = 0.01), 
                            "]")) %>% 
  
  # Select columns for the final table:
  dplyr::select(1:7, mmr2_wvce, mmr2_95ci) %>% 
  
  # Reduce Sample fraction to two decimal places for display:
  mutate(Sample_fraction = round(x = Sample_fraction, digits = 2)) %>% 
  
  # Reduce Sample weights to two decimal places for display:
  mutate(Sample_weights = round(x = Sample_weights, digits = 2)) %>% 
  
  # Convert to a flextable:
  flextable::flextable() %>% 
  
  # Add nice theme:
  flextable::theme_booktabs(bold_header = TRUE) %>% 
  
  # Add labels:
  flextable::set_header_labels(values = list(Stratum_id = "Stratum", 
                                             Stratum_name = "Area", 
                                             Area_type = "Type", 
                                             Total_pupils = "Population", 
                                             Selected_pupils = "Surveyed", 
                                             Sample_fraction = "Fraction",                                                      Sample_weights = "Weights", 
                                             mmr2_wvce = "MMR-2 VCE", 
                                             mmr2_95ci = "95% CI")) %>% 
  
  # Adjust column widths to fit text:
  flextable::set_table_properties(layout = "autofit") %>% 
  
  # Left-align first column (stratum ID):
  flextable::align(j = 1, align = "left", part = "all") %>% 
  
  # Right-align last 2 columns (weighted VCE and 95% CI):
  flextable::align(j = 8:9, align = "right", part = "all")

```

\newpage

### Task 4.5 - Estimating vaccination coverage

**Background:**

Now that you are familiar with how to calculate vaccination coverage
with different sampling strategies and survey designs, you can apply
this knowledge to estimate vaccine coverage for different
sub-populations and contexts. The objective of this task is to complete
tables 4.5.1 and 4.5.2 in the main case study guide.

**Task description:**

*A - table 4.5.1:*

Calculate the proportion of children that were fully vaccinated (using
the variable `vacful` ) and corresponding 95% confidence intervals with
the following survey designs:

-   as if simple random sampling were used;

-   allowing for weights by `strata`;

-   allowing for weights by `strata` and clustering by `school` class;

-   allowing for weights, clustering and stratification (separate result
    for each stratum).

You will also need to calculate:

-   the design effect (for each estimate of vaccination coverage)

-   the intra-class correlation coefficient (for the whole study).

*B - table 4.5.2:*

Estimate vaccination coverage for all the vaccines in the data set
separately (including the total sub-population *N* , 95% CI and the
design effect) for the following sub-groups:

-   overall population

-   different minority groups (`minority`)

-   urban and rural areas (`urban`)

Then perform the same calculations for these sub-groups, this time
looking at:

-   complete vaccination (`vacful`)

-   timeliness of vaccination (`vactime` )

**R coding tips:**

Refer to the blank tables (4.5.1 and 4.5.2) to decide how you will
structure your analysis, using the techniques already demonstrated in
the previous tasks.

You may wish to run the code from previous sessions before starting, to
ensure that you are working with the most up to date `vaccine`
data.frame that includes any cleaning, labelling, reclassification or
other edits to key variables that you have already made.

Remember that the formula for calculating the design effect $deff$ was
presented in task 2.2. You can use the same formula to solve for $rho$
(the intra-cluster correlation coefficient) by extracting the design
effect from the output of the `sitrep::tab_survey()` command that you
will be using to calculate vaccine coverage. You can create different
types of design (with and without weights, stratification or clustering)
using the `srvyr::as_survey_design()` command as the input to
`sitrep::tab_survey()` .

## Task 4.5 - Estimate vaccination coverage

You will now estimate the vaccination coverage of children for different
vaccines and in different settings, using the **survey** package in R.

#### Calculate the proportion of children that were fully vaccinated (vacful) and the corresponding 95%CI

-   as if simple random sampling were used\
-   allowing for the weights\
-   allowing for the weights and clustering\
-   allowing for the weights, clustering and stratification

Complete Table 4.4.1 Comment on the results.

## Help, Task 4.5

You can use the survey package in R, which allows you to analyse survey
data taking into account the sampling design (stratification, multistage
sampling, cluster sampling) e.g. calculate proportions, allowing for the
weights, stratification and clustering. These commands can be used for
means, proportions, ratios and sums, but also for the estimation of
regression coefficients (univariate and multivariate regressions).

You need to use the function **svydesign** to define the design to be
applied to the survey.

More information can be found in R help, but the essentials are
summarised below:

*svydesign(ids, strata = NULL, weights = NULL, data = NULL)*

-   **ids**: designates the name of the variable that contains
    identifiers for the primary sampling units (e.g. clusters = school
    in this study). Ids take a value of **\~0 or \~1** if there are no
    clusters
-   **strata**: designates the name of the variable that contains
    identifiers for the strata (e.g. strata = urban/rural areas of each
    region in this study), to allow for stratification
-   **weights**: designates the variable of the sampling weight used,
    i.e. allows for the sampling weight of each individual
-   **data**: specifies the relevant data frame

You may use the function **svymean** or **svyciprop** to estimate
proportions for **dichotomous variables**. Of note, **syvciprop**
provides **more accurate confidence intervals** compared to svymean.
However, it doesn't provide the design effect. We will use a combination
of svyciprop and svymean to obtain all the elements we need. **svyby**
can be used to estimate proportions in different subpopulations (see
below for explanations of options for each function).

*svymean(x, design, na.rm = FALSE, deff = FALSE)*

The options for svymean include:

-   **x**: a variable, a formula or matrix
-   **design**: the object created using svydesign
-   **na.rm**: should cases with missing values be dropped?
-   **deff**: return the design effect

*svyciprop(formula, design, level = 0.95, method = c("logit",
"likelihood", "asin", "beta", "mean", "xlogit"))*

The options for svyciprop include:

-   **formula**: model formulat specifying a single binary variable
-   **design**: the object created using svydesign
-   **level**: confidence interval level
-   **method**: method to be used

*svyby(formula, by, design, FUN, deff = FALSE, vartype =
c("se","ci","cv","cvpct","var")*

The options for svyby include:

-   **formula,x**: a variable, a formula or matrix to pass to the
    function
-   **by**: a formula specifying factors that define subsets, or a list
    of factors
-   **design**: the object created using svydesign
-   **FUN**: a function taking a formula and survey design object as its
    first two arguments
-   **deff**: request a design effect from FUN
-   **vartype**: report variability in terms of standard error,
    confidence intervals and more

#### Calculate the simple proportion (unweighted) and 95% CIs

```{r}
# Make vacful a factor and reorder in order to obtain proportion/ CI
vacc_rec$vacful <- factor(vacc_rec$vacful, levels = c(1, 0))

# Use prop.test to obtain the proportion and the CI
simple <- prop.test(table(vacc_rec$vacful))

# Extract the proportion, confidence intervals from the simple table and add 1 as the design effect for a simple proportion
simple <- rbind(round(simple$estimate * 100, digits = 2),
                round(simple$conf.int[1] * 100, digits = 2), 
                round(simple$conf.int[2] * 100, digits = 2),
                1)

# Make simple a data frame and use the transpose function to switch rows to columns
simple <- as.data.frame(t(simple))

# Add column names to the simple data frame
colnames(simple)[1:4] <- c("Proportion", "2.5%", "97.5%","Design effect")
simple
```

```{r}
# We must convert vacful back to a numeric variable for the subsequent calculations, as follows:
# Factor variables must be first converted to characters and then to numeric
vacc_rec$vacful <- as.numeric(as.character(vacc_rec$vacful))
```

#### Calculate a weighted proportion and 95% CIs (taking into account the sampling weights)

We first need to define the survey design. By specifying that ids = \~1,
we ignore clusters in the data.

```{r}
design <- svydesign(ids = ~1, weights = ~weight1, data = vacc_rec)
```

We can obtain the proportion, confidence intervals and design in a
multi-step process as below.

```{r, eval=FALSE}
# NB.any records that contain NAs must be dropped to calculate the proportion using svymean
# We use svyciprop to calculate proportions and specifically for 95% CI of proportions
a <- round(svyciprop(~vacful, design, na.rm = T) * 100, digits = 2)
# Save the 95% CI separately
b <- round(confint(a) * 100, digits = 2)
# Use svymean to calculate the design effect
c <- deff(round(svymean(~vacful, design, na.rm = T, deff = T) * 100, digits = 2))
# Put them all together with correct labelling
d <- cbind("Proportion" = a, b, "Design effect" = c)
d
```

Alternatively, we can use the **svy_prop** function (defined at the
start of the case study), which carries out the above 4 steps but keeps
the code neater.

```{r}
e <- svy_prop("vacful", design = design)
e
```

#### To estimate the proportion of children that were fully vaccinated, allowing for the weights and clustering:

To include clustering in the design, we define the primary sampling
unit/ids as school.

```{r}
design2 <- svydesign(ids = ~school, weights = ~weight1, data = vacc_rec)

# Use the svy_prop function specifying that design2 should be used
f <- svy_prop("vacful", design = design2)
f
```

#### To estimate the proportion of children that were fully vaccinated, allowing for the weights, clustering and stratification:

To include stratification in the design, we define that strata equals
strata.

```{r}
design3 <- svydesign(ids = ~school, weights = ~weight1, strata = ~strata, data = vacc_rec)
g <- svy_prop("vacful", design = design3)
g
```

To create table 4.4.1, we need to combine all of these elements
together.

```{r}
# Combine simple with e, f, and g
table4 <- rbind(simple,e,f,g)

# Round the values
table4[, 2:4] <- round(table4[, 2:4], digits = 3)

# Add in row names
rownames(table4) <- c("Simple proportion",
                      "+ sampling weight",
                      "+ sampling weight + clustering",
                      "+ sampling weight + clustering + stratification")
```

```{r, echo = FALSE}
kable(table4)
```

Of note, the CIs and the design effects obtained from R and Stata are
not exactly the same, however, their interpretation remains similar.

Estimations are modified when the sampling design is taken into account:

-   allowing for the sample weight modifies the estimate of vaccination
    coverage
-   allowing for the clustering (or multistage design) decreases the
    precision of the estimate (higher variance and design effect)
-   allowing for the stratification improves the precision of the
    estimate (lower variance and design effect) Note that the point
    estimate depends on the weights only, while the 95% CIs depend on
    everything (weights, stratification and clustering).

#### Design effects and intraclass correlation coefficient

A design effect of **1.407** suggests that the variability (variance or
the square of the standard error) of the estimate under the chosen
design is **40.7%** larger than that of the same-sized simple random
sampling. Similarly, a design effect of 2.358 suggests that the
variability of the estimate allowing for clustering, stratification and
sampling weights is 135.8% larger than that would come from the same
sample size if simple random sampling were used.

Rearranging the formula: deff=1+(n-1) ? rho ==\> rho=(deff-1)/(n-1)
where deff=2.358 and n=20, you can get intraclass correlation
coefficient (rho)=0.071

You may use this value of rho in sample size calculations in other
similar surveys in the future. As mentioned earlier, the rho is the
proportion of the total variation in the outcome that is between
clusters; this measures the degree of similarity or correlation between
subjects within the same cluster. The larger the rho-that is the
tendency for subjects within a cluster to be similar-the greater the
size of the design effect and the larger the additional number of
subjects required to achieve the same precision.

Note that in the sample size calculations in session 2, deff and rho
were expected to be higher (2 and 0,05, respectively). Hence, the sample
size actually achieved was larger and the estimates were more precise
than originally expected.

#### Calculate the vaccination coverage and complete Table 4.4.2

For example, DTP-3:

```{r}
# Weighted vaccine coverage of DTP-3
dtp <- svy_prop("dtp3yn", design = design3)
dtp

# Weighted vaccine coverage of DTP-3 by minority group
dtm <- svyby(~dtp3yn, ~minority,
             design3,
             svyciprop, vartype = "ci")
dtm <- round(dtm[,2:4] * 100, digits = 2)
dtm

# Weighted vaccine coverage of DTP-3 by area
dtu <- svyby(~dtp3yn, ~urban, 
             design3,
             svyciprop, vartype = "ci")
dtu <- round(dtu[,2:4] * 100, digits = 2)
dtu
```

Creating table 4.4.2 will take a few steps, as outlined below.

**Step 1:** Use a loop to estimate overall vaccination coverage for all
vaccines.

```{r}
vars <- c("dtp3yn", "dtp4yn", "dtp5yn", "mmr1yn", "mmr2yn", "hibprmyn", "hibfulyn", "hbv3yn", "mnc1yn", "pne1yn", "var1yn", "vacful", "vactime")

# Create an empty list to store the output of the loop
output <- list()

# for each variable in vars
for (var in vars) {
# Calculate the proportion, 95% CI and deff
  overall <- svy_prop(var, design = design3)
  output[[var]] <- overall
}

# Bind dataframes from the list (output) as rows below each other in a matrix
output2 <- do.call(rbind, output[1:length(output)]) 

# Transform output2 to a dataframe
output2 <- as.data.frame(output2)

```

**Step 2:** Use a loop to estimate vaccination coverage for DTP-3,
complete vaccination and timely vaccination **by minority.**

```{r, warning = FALSE, message = FALSE}
vars <- c("dtp3yn", "vacful", "vactime")

# Create an empty list to store the output of the loop
output3 <- list()
  
for (var in vars) {
# Calculate proportions, 95% CI and deff for vars by minority
  a <- svyby(as.formula(paste0( "~" , var)),
             by = ~minority, design3, 
             svyciprop, vartype = "ci")
#  Change the column names to facilitate merging
  colnames(a)[2:4] <- c("Proportion", "2.5%","97.5%")
  a <- round(a[,2:4]*100, digits = 1)
  output3[[var]] <- a
}  

# Bind dataframes from the list (output3) as rows below each other in a matrix
output3 <- do.call(rbind, output3[1:length(output3)])

# Need to add an empty Design effect variable to be able to combine all of the dataframes later
output3$`Design effect` <- ""
```

**Step 3:** Use a loop to estimate vaccination coverage for DTP-3,
complete vaccination and timely vaccination **by area.**

```{r}
vars <- c("dtp3yn", "vacful", "vactime")

# Create an empty list to store the output of the loop
output4 <- list()

for (var in vars) {
# Calculate proportions, 95% CI and deff for vars by area
  b <- svyby(as.formula(paste0( "~" , var)),
             by = ~urban, design3, 
             svyciprop, vartype = "ci")
#  Change the column names to facilitate merging  
  colnames(b)[2:4] <- c("Proportion", "2.5%","97.5%")
  b <- round(b[,2:4]*100, digits = 1)
  output4[[var]] <- b 
}  

output4 <- do.call(rbind, output4[1:length(output4)])

# Create an empty Design effect variable to be able to combine all of the dataframes later
output4$`Design effect` <- ""
```

**Step 4:** Combine the tables, while trying to follow the table
structure in the manual as much as possible.

```{r}
finaltable <- rbind(output2[1,],
                    output3[1:4,],
                    output4[1:2,],
                    output2[2:12,],
                    output3[5:8,],
                    output4[3:4,],
                    output2[13,],
                    output3[9:12,],
                    output4[5:6,])
```

**Step 5:** Tidy up the table with rownames and rounding of variables
(found in the appendix).

```{r,echo = FALSE}
# Add appropriate rownames
rownames(finaltable) <- c("DTP-3 (overall)", "DTP-3 General population", "DTP-3 Roma", "DTP-3 Greek Muslims", "DTP-3 Immigrants", "DTP-3 Rural areas", "DTP-3 Urban areas", "DTP-4 (overall)","DTP-5 (overall)", "MMR-1 (overall)", "MMR-2 (overall)", "HiB- primary (overall)", "HiB- full (overall)", "HepB-3 (overall)", "MNC-1 (overall)", "PCV7-1 (overall)", "Var-1 (overall)", "Complete vaccination (overall)",  "Comp Vacc General population","Comp Vacc Roma", "Comp Vacc Greek Muslims", "Comp Vacc Immigrants", "Comp Vacc Rural areas", "Comp Vacc Urban areas", "Timely vaccination (overall)", "Timely vacc General population", "Timely vacc Roma", "Timely vacc Greek Muslims", "Timely vacc Immigrants", "Timely vacc Rural areas", "Timely vacc Urban areas")

# Design effect needs to be numeric to round the values
finaltable$`Design effect` <- as.numeric(finaltable$`Design effect`)

# round values
finaltable[,2:4] <- round(finaltable[,2:4], digits = 2)

# convert NA values to "" 
finaltable[is.na(finaltable) == T ] <- "" 
```

```{r, echo = FALSE}
knitr::kable(finaltable)
```

# Appendix

### Making table 4.1

You could use the following code to make a table similar to table 4.1:

```{r, eval = F}
# List your variales of interest
vars <- c("gender", "urban", "minority", "country1")

# Make an empty list to store output
output <- list()

# Use the loop to obtain count & proportions of variables in the full sample and by vaccrec, and result of chisq test
for (var in vars) {
  full <- big.table(vaccine[,var])
  combo <- table(vaccine[,var], vaccine$vaccrec)
  prop <- round(prop.table(combo,2)*100,digits = 2)
  test <- chisq.test(combo)
  output[[var]] <- cbind(total,
                         "Respondents (n)" = combo[,c(2)],
                         "% respondents" = prop[,c(2)],
                         "Non-respondents (n)" = combo[,c(1)], 
                         "% non-respondents" = prop[,c(1)],
                         Pvalue = round(test$p.value, digits = 3))
}

output

## Use the Do.call function which will loop over output with rbind to create a neater table
output2 <- do.call(rbind, output[1:length(output)]) 

# Add in appropriate variable names
rownames(output2) <- c("Female", "Male", "Rural areas", "Urban areas", "General population", "Roma", "Greek Muslims", "Immigrants", "Other country", "Greece")

# Note that the final order isn't exactly the same as table 4.1
output2
```

### Tidying up table 4.4.2

```{r, eval = F}
# Add appropriate rownames
rownames(finaltable) <- c("DTP-3 (overall)", "DTP-3 General population", "DTP-3 Roma", "DTP-3 Greek Muslims", "DTP-3 Immigrants", "DTP-3 Rural areas", "DTP-3 Urban areas", "DTP-4 (overall)","DTP-5 (overall)", "MMR-1 (overall)", "MMR-2 (overall)", "HiB- primary (overall)", "HiB- full (overall)", "HepB-3 (overall)", "MNC-1 (overall)", "PCV7-1 (overall)", "Var-1 (overall)", "Complete vaccination (overall)",  "Comp Vacc General population","Comp Vacc Roma", "Comp Vacc Greek Muslims", "Comp Vacc Immigrants", "Comp Vacc Rural areas", "Comp Vacc Urban areas", "Timely vaccination (overall)", "Timely vacc General population", "Timely vacc Roma", "Timely vacc Greek Muslims", "Timely vacc Immigrants", "Timely vacc Rural areas", "Timely vacc Urban areas")

# Design effect needs to be numeric to round the values
finaltable$`Design effect` <- as.numeric(finaltable$`Design effect`)

# round values
finaltable[,2:4] <- round(finaltable[,2:4], digits = 2)

# convert NA values to "" 
finaltable[is.na(finaltable) == T ] <- "" 
```

### Tidying up table output using ReporterRs package

```{r}
# Functions used to format tables
label_table <- function(X){
  setFlexTableBorders(X,inner.vertical = borderProperties(style = "none"),inner.horizontal = borderProperties(style = "none"),outer.vertical = borderProperties(style = "none"),outer.horizontal = borderProperties(width = 2),body = T,header = T)
} 

label_footer <- function(X){
  setFlexTableBorders(X,inner.vertical = borderProperties(style = "none"),inner.horizontal = borderProperties(style = "none"),outer.vertical = borderProperties(style = "none"),outer.horizontal = borderProperties(style = "none"),footer = T)
}
```

```{r, eval = F}
# To make publication standard tables through R, you can use the FlexTable function from the ReporteRs package
table3 <- FlexTable(table3,header.columns = F)

# this adds a new row with those headings and you specify over how many columns each heading should span
table3 <- addHeaderRow(table3, text.properties = textBold(), value = c("Stratum", "Total number of 1st year pupils", "Number of pupils selected in sample", "Sampling fraction (%)", "Sampling weight", "MMR-2 vaccination coverage (%)"), colspan = c(1,1,1,1,1,1)) 

 #  removed the label around the footer
table3 <- label_footer(table3)

 # formatted the table so that only the top and lower parts are neatly formatted
table3 <- label_table(table3) 

 # Can export the table to e.g. powerpoint
doc1 <- pptx()

doc1 <- addSlide( doc1, "Two Content")
doc1 <- addTitle( doc1 , 'Table3', level = 1)
doc1 <- addFlexTable(doc1, flextable = table3)
writeDoc( doc1, 'N:/MED/IMED-VIE/INFE/Public/CC-INFE-Schmid/EPIET/Output/Table3.pptx')

```
