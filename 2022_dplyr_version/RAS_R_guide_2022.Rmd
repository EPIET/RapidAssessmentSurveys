---
title: "RAS Case study in R" 
subtitle: "Childhood vaccination coverage survey in Greece, 2006"
author: "Amy Mikhail and Alexander Spina (Applied Epi)"
date: "Date revised: 27 May 2022"
output:
  html_document:
    code_folding: hide
    toc: true
    toc_float:
      toc_collapsed: true
    toc_depth: 3
  pdf_document:
    toc: true
    toc_depth: 3
  word_document:
    toc: true
    toc_depth: 3
theme: sandstone
geometry: margin = 1.5cm
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      eval = TRUE,
                      results = 'hide', 
                      message = FALSE, 
                      warning = FALSE)
```

**Contributing authors and version history:**

This case study was originally written by the following authors:

-   Kostas Danis
-   Dimitris Papamichail
-   Takis Panagiotopoulos

An R companion guide for the computer practicals accompanying the case
study was developed in 2017 by:

-   Patrick Keating
-   Alexander Spina
-   Alexandre Blake

This was updated in 2018 by:

-   Ashley Sharpe

Further updates were made in 2022, to replace base R code with more
modern functions from `tidyverse` packages and to add an alternative
mixed-methods based approach for section 6 following discussions with
the module organizers, by:

-   Amy Mikhail
-   Alexander Spina

All copyrights and licenses of the original document apply here as well.

\newpage

# Introduction to the R companion guide

This guide is an R companion guide to the main case study document.
Participants are advised to follow the case study sections in the main
document to read the background information for each task, and refer to
this document for every exercise that requires some analysis to be
performed. For convenience, the questions for each analysis task have
also been reprinted here.

Note that this guide has been updated to use readily available and
currently maintained R packages. As such, there may be some minor
differences in approach or results when compared to STATA. To read more
about the methods underlying each R function, see the relevant help
file, e.g. `?package::function`.

## Prerequisites

Participants are expected to be familiar with data management and basic
analysis in R and RStudio. It is advisable to have up-to-date versions
of both softwares installed. The code in this guide was updated and
tested using:

-   R version 4.1.3 (2022-03-10)
-   RStudio version 2022.02.0 Build 443

## R packages

This guide uses packages from the `tidyverse` which are being used more
and more for data analysis, due to their easy to read and efficient
coding syntax. The approach for setting up an RStudio project, importing
and cleaning data and managing code, as well as creating summary tables
and graphs follows that presented in the [Epidemiologist R
handbook](https://epirhandbook.com/en/) (click on the link to access
it).

The packages required for this case study can be installed by running
the code below. This code has also been made available as a separate R
script. It uses the `pload()` function from the `pacman` package as this
will check the user's library for required packages, install them if
they are missing, and then load them into the current R session. This
code should therefore be rerun at the beginning of each session, to
ensure that all the required libraries are loaded.

```{r packages, results='hide', message=FALSE, warning=FALSE}

# Packages to install *before* running pacman pload():
#####################################################

# Ensures the package "pacman" is installed
if (!require("pacman")) install.packages("pacman", quiet = TRUE)

# Ensure the package "remotes" is installed
if (!require("remotes")) install.packages("remotes", quiet = TRUE)

# Install the epikit package from Github:
if (!require("epikit")) remotes::install_github("R4EPI/epikit", quiet = TRUE)

# Install the sitrep package from Github:
if (!require("sitrep")) remotes::install_github("R4EPI/sitrep", quiet = TRUE)


# Install and/or load required packages:
########################################
pacman::p_load(
  
  # Project and file management
  #############################
  here,      # file paths relative to R project root folder
  rio,       # import/export of many types of data
  rmarkdown, # reading and printing RAS R markdown guide
  knitr,     # reading and printing RAS R markdown guide
  
  # Package install and management
  ################################
  pacman,   # package install/load
  remotes,  # install from github
  
  # General data management
  #########################
  tidyverse,   # includes many packages for tidy data wrangling:
  #dplyr,      # data management
  #tidyr,      # data management
  #ggplot2,    # data visualization
  #stringr,    # work with strings and characters
  #forcats,    # work with factors 
  #lubridate,  # work with dates
  #purrr       # iteration and working with lists
  janitor,     # data cleaning
  
  # Summary tables:
  #########################
  flextable,   # Creating printable summary tables
  officer,     # Fine tuning flextables
  gtsummary,   # making descriptive and statistical tables
  smd,         # Helper functions for gtsummary tables
  labelled,    # Labelling variables and values
  scales,      # helper functions
  
  # RAS analysis:
  #########################
  pps,         # Probability proportional to size (PPS) sampling
  sampler,     # Calculate sample size
  srvyr,       # Create survey design and calculate vaccination coverage
  survey,      # Support for srvyr functions
  Hmisc        # Summary functions
)

# Check for and install Github packages:
pacman::p_load_gh(
  
  # Packages for survey analysis and mixed effects:
  #################################################
  "R4EPI/epikit",      # Functions for survey analysis
  "R4EPI/sitrep"      # Function wrappers for survey analysis
)

```

\newpage

## Data management

**File organisation:**

The R practical material for this case study is stored in a folder
called `rvcs_2022`. Please download this folder from EVA and save it on
your computer.

There is an R project file (`.Rproj`) in this folder and we suggest you
begin this practical session by double clicking on this file to open it.

You can then create a new R script called `vcsurvey.R` and save it in
the `rvcs_2022` folder.

The data sets have been stored in a sub-folder called `data`.

Note that the relative file paths used for importing data in this guide
assume the above folder structure.

**Importing data sets:**

The data sets can be easily imported using the `import()` function from
the `rio` package, combined with the `here` package to construct
relative file paths.

Most of the data sets are STATA `.dta` files, while one file for the
first exercise is a Microsoft Excel workbook. Both file types can be
read in to R using `rio::import()` and specifying the relevant
arguments.

\newpage

# Guidance and code for practical sessions

In the sections below, you will find a brief background and description
for each task, followed by an explanation of how to complete the task
using R, that highlights suggested packages and functions. This is then
complemented by some example code.

The example code has been presented in full, so that you can reference
it when undertaking similar analyses with your own data in future. If
you are working from the HTML version of this document, the code will
initially remain hidden, so that you can attempt to write your analysis
script using just the R coding tips as a guide if you wish. To reveal
the code, click on the `code` button that appears at the top of each
coding section.

Notes:

-   Only the tasks which require data manipulation or analysis in R are
    reprinted below

-   Begin with the main case study guide and refer to this R companion
    when a task is introduced that requires computational analysis.

-   To undertake the practical tasks, you will need to create your own R
    script and either write your own code (using the R coding tips in
    this document and package help files as a guide) or copy the example
    code into your script and run it, to see the results.

\newpage

## Session 1: Sampling frames

### Task 1.2 - stratified proportional sampling

**Background:**

In the main guide, you have been provided with the background and aims
of this case study, which is to undertake a vaccination coverage survey
in school children in Greece. A two-step stratified proportional cluster
sampling strategy has been selected. Your first task is to calculate the
number of classes to sample in each region and rural / urban stratum:

**Task instructions:**

Using the data provided in table 1.2 below (which can be imported into R
from the `table1_2` worksheet of the `Sampling_frames.xlsx` Microsoft
Excel workbook in the `data` sub-folder):

1.  Within each region, calculate the number of clusters (school
    classes) to sample from;

2.  Calculate the number of classes for each urban / rural stratum
    relative to the population size;

3.  Aim to include 50 school classes from each region;

4.  Assume that all school classes have an equal number of students;

5.  Complete table 1.2 in the main case study guide with your results
    (percentage and number of classes to sample for each urban and rural
    stratum in each of the 6 regions).

| Region                 |  Urban |  Rural |  TOTAL |
|------------------------|-------:|-------:|-------:|
| Thraki                 |  11624 |   6884 |  18508 |
| Macedonia-Thessalia    | 116322 |  47101 | 163423 |
| Ipeiros-Ionian Islands |  11446 |  15449 |  26895 |
| Peloponissos-Sterea    |  55770 |  44132 |  99902 |
| Attiki                 | 174493 |   1667 | 176160 |
| Crete-Aegean Islands   |  36374 |  24752 |  61126 |
| **TOTAL**              | 406029 | 139985 | 546014 |

: Table 1.2 - Number of children aged 5 - 9 years in Greece by region
and urban/rural area

**R coding tips:**

First, import the summary data from table 1.2.

This table is currently in wide format, but to calculate the number of
classes to sample from in each strata, it needs to be converted to long
format (i.e. 'tidy data') so that a single column defines the strata
(urban or rural) and another column contains the population for each
stratum. We can do this with the `tidyr::pivot_longer()` function.

We can then calculate the relative proportions in each stratum and from
there determine the number of school classes to sample (out of 50) for
each stratum within each region:

```{r sframe_import}

# Import sample frame for regions:
regions <- rio::import(here::here("data", "Sampling_frames.xlsx"),
                         which = "table1_2")

# Create new table for results:
rsf_long <- regions %>% 
  
  # Convert table to tidy data:
  tidyr::pivot_longer(cols = c(Urban, Rural),        # Convert to tidy format
                      names_to = "Stratum",          # Store strata in new col
                      values_to = "Population") %>%  # Store population in new col
  
  # Calculate proportions and number of classes to sample:
  mutate(Proportion = Population/Total,              # Calculate proportions
         Nclasses = round(50*Proportion, digits = 0))# Calculate number of classes

  

```

\newpage

### Task 1.3 - simple random sampling

**Background:**

Table 1.3 is part of the sampling frame for the stratum "rural areas of
the region of Peloponissos-Sterea", where all schools have only one
first grade school-class.

**Task instructions:**

1.  Generate a simple random sample of 22 school classes using random
    number selection;

2.  Identify the selected school classes in the sampling frame (table
    1.3);

3.  Calculate the sampling fraction.

**R coding tips:**

The sampling frame (list of school classes in the Peleponissos-Sterea
region) can be imported from the `Sampling_frames.xlsx` workbook
(`table1_3` is the name of the worksheet).

The simple random sample of 22 classes can then be identified using the
`dplyr` convenience function `slice_sample()` to return a random subset
of 22 rows of the original sampling frame.

```{r simple_random_sample}

# Import the sampling frame of school classes in Peleponissos-Sterea:
class_frame <- rio::import(here::here("data", "Sampling_frames.xlsx"),
                         which = "table1_3")


# Perform a simple random sample to select 22 classes from the list:
class_list <- class_frame %>% 
  
  # Subset the simple random sample of 22 classes:
  slice_sample(n = 22) %>% 
  
  # Arrange results in ascending order by ID:
  dplyr::arrange(ID)

```

The sampling fraction is the number of units sampled divided by the
total number of units in the sampling frame, i.e.:

```{r sample_fraction}

# Calculate the sampling fraction for this example:
sample_fraction <- round(22/nrow(class_frame), digits = 2)

```

\newpage

### Task 1.4 - systematic sampling

**Background:**

Systematic sampling is similar to simple random sampling except that the
total sampling frame is divided by the desired number of sampling units
to select and every *nth* row of the sampling frame is selected
according to the result. This can be useful when subjects are being
prospectively recruited to a study, when the total size of the sampling
frame is not yet clear or when it is necessary to ensure consistent
sampling over multiple days with an unknown number of subjects recruited
per day.

**Task instructions:**

1.  Use the same sampling frame as for the previous section
    (`class_frame`);

2.  Divide the total number of classes in the sampling frame by the
    desired number of units to sample (22) to calculate the group size;

3.  Randomly select one number *n* from this group size;

4.  Select every *nth* row of the sampling frame to produce the
    systematic sample;

5.  Limit the number of returned rows to the desired number of units to
    sample (22).

**R coding tips:**

After calculating the size of the groups to divide the sampling frame
into, we can select a random number from this group size using the base
R function `sample.int()`.

Note that you can ensure you always get the same number back by using
the `set.seed()` function - this way if you send your script to someone
else they would be able to reproduce the same sample.

This random number can then be fed into the `dplyr::slice()` command as
shown below to select every *nth* row of the sampling frame. Note that
if *n* is small / an early number in the sequence, an excess of rows may
be selected. If this happens, the returned rows can be limited to the
desired sample size by using the `dplyr::slice_head()` function:

```{r systematic_sample}

# Define the sampling interval - the n to systematically sample 
# (i.e. every nth row to choose):
sample_n <- as.integer(nrow(class_frame)/22)

# Calculate the random starting point for systematic sampling:
sample_start <- sample.int(n = sample_n, size = 1)

# Define rows systematically (every nth row) to filter the sampling frame: 
sample_rows <- seq.int(sample_start, nrow(class_frame), sample_n)

# Now subset the sampling frame and filter for every nth row:
class_system <- class_frame %>% 
  
  # Select every nth row from the sampling frame:
  slice(sample_rows) %>% 
  
  # Limit the number of returned rows to the desired sample size (22)
  slice_head(n = 22)
  
```

\newpage

### Task 1.5 - Probability Proportional to Size sampling

**Background:**

The researchers originally chose to use school classes as the sampling
units, because it was assumed that all classes had similar numbers of
students. An alternative sampling unit would be the schools themselves;
however unlike for classes, the number of students in each school varies
widely.

Probability proportional to size (PPS) sampling is a method that takes
varying sample sizes in the sample units into account. This helps to
avoid under-representing one subgroup in a study and yields more
accurate results.

In this case study, you have been provided with a list of schools in
urban areas of Attiki, which also indicates the number of grade 1
students in each school and the number of classes. This data set can be
imported from the `table1_5` worksheet in the `Sampling_frames.xlsx`
workbook. Schools can be selected adjusting for the size of the student
population, by performing PPS sampling. The column containing the number
of students in each school is used as input.

**Task instructions:**

1.  Use the sampling frame for Attiki schools in urban areas presented
    in `table1_5`

2.  Select 12 schools by probability proportional to size sampling
    *without replacement*

3.  Indicate which schools have been selected in table 1.5 in the main
    case study guide

**R coding tips:**

There are several packages available on CRAN that can perform PPS
sampling. In the example code below, we will use the `sampford()`
function from the `pps` package to perform the sampling without
replacement, which uses the classic method developed by [Sampford
(1967)](https://academic.oup.com/biomet/article-abstract/54/3-4/499/230469?redirectedFrom=fulltext).

We can use the indices in the results to filter the sampling frame for
the 12 selected schools (using `dplyr::slice()` as above).

Note that an alternative would be to use `dplyr::slice_sample()` and
supply probabilities for each school to the `weight_by` argument. To do
this you would have to calculate probabilities for each school:
`school_frame %>% mutate(probability = Students / sum(Students))`.

We opted for using the `pps::sampford()` function, as the documentation
on methods is more transparent.

```{r pps_sample}

# Import the sampling frame of urban schools with grade 1 classes in Attiki:
school_frame <- rio::import(here::here("data", "Sampling_frames.xlsx"), 
                            which = "table1_5")

# Perform PPS sampling to select 12 schools:
schools2survey <- school_frame %>% 
  
  # Select schools by PPS without replacement:
  slice(pps::sampford(size = Students, n = 12))

```

\newpage

## Session 2 - sample size calculations

### Task 2.1 - sample size for single proportion

**Background:**

For each region, a sampling frame has been returned indicating the total
number of students in the target class / age group. The sampling frame
sizes by region are shown in table 2.1 below.

The researchers now need to calculate sample sizes for each region,
given the parameters described below:

-   Vaccination coverage in previous surveys exceeded 85% for most
    vaccines;

-   Sample sizes will be calculated with a target precision of +/- 4% ;

-   The response rate from previous surveys was approximately 87.5%.

| Region                     | Number of pupils (sampling frame) |
|----------------------------|----------------------------------:|
| Thraki                     |                              4201 |
| Macedonia-Thessalia        |                             31045 |
| Ipeiros-Ionian Islands     |                              5055 |
| Peloponnisos-Sterea Ellada |                             17741 |
| Attiki                     |                             30586 |
| Kriti-Aegean Islands       |                             12218 |
| **Greece (total)**         |                            100846 |

: Table 2.1 - Total number of pupils recorded in the sampling frame, by
region.

**Task description:**

1.  Calculate the single proportion sample size required for each
    region, assuming simple random sampling;

2.  Use the per region student population, previous vaccination coverage
    estimate and the desired precision presented above in the
    calculations;

3.  Adjust the calculations to take into account the lower response rate
    (87.5%) achieved in previous surveys.

**R coding tips:**

The sampling frame sizes by region in table 2.1 can be imported into R
from the `table2_1` worksheet in the `Sampling_frames.xlsx` workbook.

To calculate sample size, we can use the `sampler` package. In the first
instance, the `rsampcalc()` function can be used for each region. The
arguments correspond to the inputs above as follows:

-   *N* = population (i.e. number of students in each region from table
    2.1)

-   *e* = tolerable margin of error (i.e. desired precision of +/- 4%)

-   *ci* = confidence interval (i.e. 95% - the default value)

-   *p* = anticipated response distribution (convert 85% vaccination
    coverage to proportion i.e. 0.85)

-   *over* = desired over-sampling proportion (convert 87.5% response to
    inverse proportion i.e. 1 - 0.875)

Note that the last argument, `over` can be used to increase the sample
size in order to compensate for a low response rate, by taking the
inverse proportion of the response rate from previous surveys (1 -
0.875) and adding this to the calculated sample size as a buffer.

To first have a look at the sample sizes without this buffer, leave this
argument on its default setting (0).

```{r sample_size_basic}

# Import the sampling frame of urban schools with grade 1 classes in Attiki:
region_frame <- rio::import(here::here("data", "Sampling_frames.xlsx"), 
                            which = "table2_1")

# Calculate sample size (number of students to survey) for each region:
region_frame <- region_frame %>% 
  
  # Calculate baseline sample size for each region:
  mutate(Sample_basic = sampler::rsampcalc(N = Student_pop, 
                                          e = 4, 
                                          ci = 95, 
                                          p = 0.85, 
                                          over = 0)) %>% 
  
  # Calculate sample size with adjustment for response rate of 87.5%:
  mutate(Sample_rradjust = sampler::rsampcalc(N = Student_pop, 
                                          e = 4, 
                                          ci = 95, 
                                          p = 0.85, 
                                          over = 1 - 0.875))

```

\newpage

### Task 2.2 - sample size calculation with design effect

**Background:**

The researchers have identified that there is likely to be variance
between school classes and between students within classes, and want to
take this into account in the sample size calculations using the design
effect. To calculate the design effect, they have provided the following
information:

-   *rho* (intra-cluster correlation coefficient): 0.05

-   mean class size: 20 students

**Task description:**

1.  Use *rho* and mean class size provided above to calculate the design
    effect;

2.  Adjust the sample sizes calculated in task 2.1 to account for the
    design effect;

3.  Calculate the total number of clusters required using the adjusted
    sample size.

**R coding tips:**

The design effect can be calculated in R using mathematical operators
with a simple formula:

$$
deff = 1 + (n - 1) \times rho
$$

where:

$deff$ is the design effect;

$n$ is the average number of subjects per cluster (e.g. mean number of
students per class);

$rho$ is the intra-cluster correlation coefficient (e.g. rate of
homogeneity for vaccination status).

The calculated design effect can then be multiplied by the original
sample size per region to adjust it. The adjusted sample sizes can be
added to a new column in the `region_frame` table that you created in
the previous task.

The number of clusters required can then be estimated by dividing the
total sample size (sum of number of students to survey in the 6 regions)
by the average cluster (class) size (20).

```{r sample_size_icc}

# Calculate the design effect given n = 20 and rho = 0.05:
deff <- 1 + (20 - 1) * 0.05

# Add new rho-adjusted sample size calculation to the table:
region_frame <- region_frame %>% 
  
  # Calculate sample size with adjustment for the design effect:
  mutate(Sample_rhoadjust = round(Sample_rradjust * deff, digits = 0))

# Calculate the number of clusters (school classes) required:
nclusters <- round((sum(region_frame$Sample_rhoadjust)) / 20, digits = 0)

```

\newpage

## Session 4 - descriptive analysis

### Tasks 4.1 & 4.2 - Sample representation

**Background:**

In this section, you will assess how well represented the target
population is among surveyed students, using key demographic variables
such as age, sex and classification of residence area type. The data
have been provided in the file `vaccine4.dta`.

**Task description:**

1.  Identify demographic variables of interest to compare in the data
    set (see data dictionary, annex 5 and 6 in the main case study
    guide);

2.  Summarize key demographic variables for respondents and
    non-respondents;

3.  Perform a statistical test to determine if any of these key
    demographic variables are differently distributed in respondents and
    non-respondents;

4.  Consider what kind of bias could have been introduced due to
    non-response (not having a vaccine book)?

5.  How would you interpret the results in the summary table in light of
    that limitation?

**R coding tips:**

Comparing the demographics of surveyed to non-surveyed students would
require access to basic information for the whole sampling frame. The
`vaccine4.dta` data only contains data for sampled students, but we can
check for any differences between those that did (respondents) and
didn't (non-respondents) have a vaccine book, to demonstrate the
principles involved (subjects who did not have a vaccine book were
excluded from subsequent analyses). This is encoded in the `vaccrec`
variable.

Before starting, you may wish to explore the data. Using the
`dplyr::describe()` command as well as the information in the data
dictionary (annex 5 and 6) will give you an overview of the data set.

The following demographic variables may be useful to include in the
summary table:

-   *vaccrec* - vaccine book received (no / non-respondent = 0, yes /
    respondent = 1)

-   *gender* - gender of the participants (0 = female, 1 = male)

-   *age* - age of the participants in years (with decimals)

-   *urban* - whether the participants are resident in an urban (1) or
    rural (0) area.

-   *minority* - ethnic grouping of the participants

-   *country1* - country or birth (levels are Other country (0) or
    Greece (1) )

The `gtsummary::tbl_summary()` function can be used to directly create a
comparative summary of gender, age, urban residence, minority group and
country of birth, stratified by receipt of a vaccine book (re-labelled
as `Non-respondent` for those that did not have a vaccine book and
`Respondent` for those that did have a vaccine book). The code below
shows you how to create `table 4.1` from the `vaccine4.dta` data set.

Statistical differences between respondents and non-respondents can be
assessed with a `t.test()` for continuous variables (such as age) and
`prop.test()` or `chisq.test()` for categorical variables (such as
gender).

You can use the results of these tests to determine if the respondents
are sufficiently representative of the whole population in the sampling
frame, or if there is a bias in this group that needs to be taken into
account.

The code below constructs the summary table in two steps:

1.  Import the data and add nice display labels to the variables of
    interest with `dplyr` and `labelled` ;

2.  Create the summary table and compute statistics with the `gtsummary`
    package.

Note that in some cases it is necessary to explicitly state that a
function is from a particular package using the
`packagename::function()` syntax, as there are other packages that have
functions with the same name but different arguments, that we also have
loaded in this R session (see for example `dplyr::select()` below).

```{r representation}

#################################################
# IMPORT DATA, LABEL VARIABLES AND FACTOR LEVELS
#################################################

# Import the vaccine coverage study data for session 4:
vaccine <- rio::import(here::here("data", "vaccine4.dta"))  %>% 
  
  # Convert vaccrec to a factor and add nice display labels:
  mutate(vaccrec = factor(vaccrec, 
                          levels = c(0, 1), 
                          labels = c("Non-respondents", "Respondents"))) %>% 
  
  # Convert gender to a labelled factor:
  mutate(gender = factor(gender,
                         levels = c(0, 1),
                         labels = c("Female", "Male"))) %>% 
  
  # Convert residence area type to a labelled factor:
  mutate(urban = factor(urban, 
                        levels = c(0, 1),
                        labels = c("Rural", "Urban"))) %>% 

  
  # Convert minority to a factor and add nice display labels:
  mutate(minority = factor(minority, 
                           levels = c(0, 1, 2, 3),
                           labels = c("General population", 
                                      "Roma", 
                                      "Greek Muslims", 
                                      "Immigrants"))) %>% 
  
  # Convert country1 (whether from Greece or not) to a labelled factor:
  mutate(country1 = factor(country1, 
                           levels = c(1, 0),
                           labels = c("Greece", "Other country"))) %>% 
  
  
  # Label variables with pretty names for the table:
                            ##  variable name = variable label
  labelled::set_variable_labels(vaccrec = "Response status", 
                                age = "Age in years", 
                                gender = "Gender of pupils",
                                urban = "Area type",
                                minority = "Minority group", 
                                country1 = "Country of birth")


#################################################
# CREATE SUMMARY TABLE BY RESPONSE STATE
#################################################

# Summarise the demographics of the two groups (+/- vaccine book) in a table:
reptable <- vaccine %>% 
  
  # Select subset of demographic variables for comparison:
  dplyr::select(vaccrec, age, gender, urban, minority, country1) %>% 
  
  # Create summary table with gtsummary:
  gtsummary::tbl_summary(
    
    # Stratify by group (no vaccine book = excluded, has book = included):
    by = vaccrec, 
    
    # Add summary stats (mean + SD for continuous, proportions for categorical):
    statistic = list(all_continuous() ~ "{mean} ({sd})",
                     all_categorical() ~ "{n} ({p}%)"),
    
    # Exclude NA (missing values) from the table:
    missing = "no") %>% 
  
  # Add tests of statistical significance of differences between groups:
  add_p(test = list(all_continuous() ~ "t.test", 
                    all_categorical() ~ "chisq.test"), 
        
        # Identify grouping variable:
        group = vaccrec,
                 
        # Define any test arguments that deviate from the default:
        test.args = list(all_tests("t.test") ~ list(var.equal = FALSE), 
                         all_tests("chisq.test") ~ list(simulate.p.value = TRUE))) %>% 
  
  # Add total numbers to column headers:
  add_overall() %>% 
  
  # Add descriptors of the stats presented to row labels:
  add_stat_label() %>% 
  
  # Individually label which row had which statistical test: 
  separate_p_footnotes() %>% 
  
  # Make variable names bold and italics:
  bold_labels() %>% 
  italicize_labels() %>% 
  
  # Tidy up column headers so stats are on second line:
  modify_header(update = list(all_stat_cols(FALSE) ~ "**{level}**<br>N = {n}", 
                              stat_0 ~ "**Overall**<br>N = {N}"))

```

\newpage

### Task 4.3 - Sampling weights

As mentioned earlier, the following sampling strategy was chosen: The
country was stratified into six regions, which, apart from the capital
region (Attica), were further subdivided into urban and rural areas, to
create 11 strata (`strata`). In each region school classes (clusters =
`school`) were randomly selected with probability proportional to the
total number of first year grammar school pupils. The sampling frame of
all school classrooms in the country for the academic year 2004-2005,
was obtained from the Greek Ministry of Education. The list contained
108 538 pupils from both public and private schools.

**Task description:**

Using the information on the 11 strata in `table 4.2` :

1.  Calculate the sampling fraction for each stratum;

2.  Calculate the sampling weight for each stratum.

**R coding tips:**

Table 4.2 can be imported into R from the `table4_2` worksheet in the
`Sampling_frames.xlsx` workbook. This table contains the names, IDs and
urban / rural status of the 11 strata, along with the total student
population from the sampling frame and the number of students selected
in each stratum.

The sampling fraction and weights can easily be calculated and added in
two new columns to the imported table with `dplyr` using the formulas
below.

The sampling fraction is given by:

$$
Sample fraction = \frac{n}{N}
$$

The sampling weights are the inverse of the sample fraction:

$$Weight = \frac{1}{(\frac{n}{N})}$$

```{r sample_weights}

###########################################
# CALCULATE SAMPLE FRACTIONS AND WEIGHTS
###########################################

# Import the summary information on the 11 strata (table 4.2):
strata_frame <- rio::import(here::here("data", "Sampling_frames.xlsx"), 
                            which = "table4_2") %>% 
  
  # Add a new column and calculate the sample fractions for each stratum:
  mutate(Sample_fraction = Selected_pupils / Total_pupils) %>% 
  
  # Add a new column and calculate the sample weights for each stratum:
  mutate(Sample_weights = 1 / Sample_fraction)


###########################################
# MERGE WITH VACCINE DATA SET
###########################################

# Add calculated fraction and weights to vaccine data set:
vaccine <- vaccine %>% 
  
  # Join the fraction and weights from strata_frame to the vaccine data set:
  left_join(y = dplyr::select(.data = strata_frame, # Identify second data set
                              
                              # Identify columns to add:
                              Stratum_id,           
                              Sample_fraction, 
                              Sample_weights),
            
            # Indicate ID columns to join by:
            by = c("strata" = "Stratum_id"))        

```

\newpage

### Task 4.4 - Weighted vaccination coverage

**Background:**

The researchers now want to use the sample weights you calculated in the
previous section to estimate MMR-2 vaccination coverage in each stratum
and subsequently in the whole country.

**Task description:**

1.  First, restrict the data set to respondents (`vaccrec == 1` )

2.  Calculate the weighted vaccination coverage for each of the 11
    strata

3.  Calculate the total vaccination coverage for the first three strata

4.  Calculate the total vaccination coverage for the whole country (all
    11 strata)

**R coding tips:**

The data set can be restricted to respondents by filtering for
`vaccrec == 1` . The variable containing MMR2 vaccination status of
respondents is called `mmr2yn`.

To calculate the weighted vaccination coverage, you can use the
`Sample_weights` variable that was created in the previous task and
apply this to the `mmr2yn` variable by `strata`.

You will first need to set up a stratified survey design, which can be
achieved with the `srvyr` package `as_survey_design()` function. This
takes the following arguments:

-   *ids* - this is for the variable containing cluster IDs - in this
    case we will not use it and set to 1[^1]

-   *weights* - enter the name of the `Sample_weights` variable here

-   *strata* - enter the name of the variable containing the `strata`
    here

[^1]: Although the researchers did have clusters in their survey design
    (school classes), for simplicity you have just been given the
    sampling frames (population and number of pupils selected) for the
    11 strata (urban and rural areas in each of the 6 regions).
    Therefore, you can undertake this task as if there were only strata
    and no clusters in the design.

You can then apply this survey design object to the `tab_survey()`
function from the `sitrep` package, which will calculate the weighted
proportions, as shown below. Note that the `sitrep` package is not yet
available on CRAN, but it can be installed from Github (see package
install section). For other ways to calculate weighted proportions, have
a look at the [Survey
chapter](https://epirhandbook.com/en/survey-analysis.html) in the
Epidemiologist R handbook.

To calculate the total weighted vaccine coverage:

1.  First multiply the weighted proportions you just calculated by the
    population in each stratum. You can do this more easily by adding
    the weighted proportions to the `strata_frame` table you were
    working with in the previous task, by using a `dplyr::left_join()`
    and creating a new column with `mutate` to hold the result.

2.  Next, calculate the sum of the product of the weighted proportions
    and per-stratum population.

3.  Finally, divide the result by the sum of the per-stratum
    populations.

You will need to do this initially for the first three strata only, and
then for all 11 strata to work out the total weighted vaccination
coverage estimate.

In the last section, we have demonstrated how to tidy up and present a
subset of the variables in the `strata_frame` table for publication,
using the `flextable` package. This creates a table object which can be
saved to a Microsoft word document and edited in MS word later, if
desired.

```{r mmr2_weighted_coverage}

###########################################
# CALCULATE MMR2 PROPORTIONS BY STRATA
###########################################

# Create new table of weighted MMR-2 vaccine coverage by strata:
mmr2cov <- vaccine %>% 
  
  # Convert vaccrec and strata to character:
  mutate(vaccrec = as.character(vaccrec), 
         strata = as.character(strata)) %>% 
   
  # Filter for respondents only:
  dplyr::filter(vaccrec == "Respondents") %>% 
  
  # Create survey design:
  srvyr::as_survey_design(ids = 1, 
                          weights = Sample_weights, 
                          strata = strata) %>% 
  
  # Create weighted proportions:
  sitrep::tab_survey(mmr2yn,           # The variable to calculate proportions on
                     strata = strata,  # The variable containing the strata
                     keep = c(1),      # The value of interest (mmr2 vaccinated)
                     wide = FALSE,     # Long format better for a lot of strata
                     deff = TRUE,      # Include the design effect in the output
                     pretty = FALSE) %>% # Do not convert to percent (yet)
  
  # Convert strata back to numeric for merging:
  mutate(strata = strtoi(strata))
  
###########################################
# CALCULATE TOTAL WEIGHTED VACCINE COVERAGE
###########################################

# Add the results to the strata_frame table:
strata_frame <- strata_frame %>% 
  
  # Add MMR-2 weighted vaccine coverage to strata_frame:
  dplyr::left_join(y = dplyr::select(.data = mmr2cov, 
                                     strata,
                                     proportion, 
                                     proportion_low, 
                                     proportion_upp), 
                   by = c("Stratum_id" = "strata")) %>% 
  
  # Calculate weighted fraction of population:
  mutate(pop_frac = Total_pupils * proportion)


###########################################################################
# Calculate the total vaccination coverage estimate for the first 3 strata:
vc_total_03 <- strata_frame %>% 
  
  # Keep the first three rows:
  slice(1:3) %>% 
  
  # Calculate the percentage:
  summarise(round(sum(pop_frac) / sum(Total_pupils) * 100, digits = 2)) %>% 
  
  # Get the number out of the data.frame: 
  pull()


# Calculate the total vaccination coverage estimate for all 11 strata:
vc_total_11 <- strata_frame %>% 
  
  # Calculate the percentage:
  summarise(round(sum(pop_frac) / sum(Total_pupils) * 100, digits = 2)) %>% 
  
  # Get the number out of the dataframe 
  pull()


###########################################
# DISPLAY STRATIFIED RESULTS IN A TABLE
###########################################

# Create a pretty flextable of the results:
mmr2pubtable <- strata_frame %>% 
  
  # Create summary display column of vaccine coverage:
  mutate(mmr2_wvce = percent(proportion, accuracy = 0.01)) %>% 
  
  # Add 95% confidence intervals:
  mutate(mmr2_95ci = paste0("[", 
                            percent(proportion_low, accuracy = 0.01), 
                            " - ", 
                            percent(proportion_upp, accuracy = 0.01), 
                            "]")) %>% 
  
  # Select columns for the final table:
  dplyr::select(1:7, mmr2_wvce, mmr2_95ci) %>% 
  
  # Reduce Sample fraction to two decimal places for display:
  mutate(Sample_fraction = round(x = Sample_fraction, digits = 2)) %>% 
  
  # Reduce Sample weights to two decimal places for display:
  mutate(Sample_weights = round(x = Sample_weights, digits = 2)) %>% 
  
  # Convert to a flextable:
  flextable::flextable() %>% 
  
  # Add nice theme:
  flextable::theme_booktabs(bold_header = TRUE) %>% 
  
  # Add labels:
  flextable::set_header_labels(values = list(Stratum_id = "Stratum", 
                                             Stratum_name = "Area", 
                                             Area_type = "Type", 
                                             Total_pupils = "Population", 
                                             Selected_pupils = "Surveyed", 
                                             Sample_fraction = "Fraction",                                                      Sample_weights = "Weights", 
                                             mmr2_wvce = "MMR-2 VCE", 
                                             mmr2_95ci = "95% CI")) %>% 
  
  # Adjust column widths to fit text:
  flextable::set_table_properties(layout = "autofit") %>% 
  
  # Left-align first column (stratum ID):
  flextable::align(j = 1, align = "left", part = "all") %>% 
  
  # Right-align last 2 columns (weighted VCE and 95% CI):
  flextable::align(j = 8:9, align = "right", part = "all")

```

\newpage

### Task 4.5 - Estimating vaccination coverage

**Background:**

Now that you are familiar with how to calculate vaccination coverage
with different sampling strategies and survey designs, you can apply
this knowledge to estimate vaccine coverage for different
sub-populations and contexts. The objective of this task is to complete
tables 4.5.1 and 4.5.2 in the main case study guide.

**Task description:**

*A - table 4.5.1:*

Calculate the proportion of children that were fully vaccinated (using
the variable `vacful` ) and corresponding 95% confidence intervals with
the following survey designs:

-   as if simple random sampling were used;

-   allowing for weights by `strata`;

-   allowing for weights by `strata` and clustering by `school` class;

-   allowing for weights, clustering and stratification (separate result
    for each stratum).

You will also need to calculate:

-   the design effect (for each estimate of vaccination coverage)

-   the intra-class correlation coefficient (for the whole study).

*B - table 4.5.2:*

Estimate vaccination coverage for all the vaccines in the data set
separately (including the total sub-population *N* , 95% CI and the
design effect) for the following sub-groups:

-   overall population

-   different minority groups (`minority`)

-   urban and rural areas (`urban`)

Then perform the same calculations for these sub-groups, this time
looking at:

-   complete vaccination (`vacful`)

-   timeliness of vaccination (`vactime` )

**R coding tips:**

Refer to the blank tables (4.5.1 and 4.5.2) to decide how you will
structure your analysis, using the techniques already demonstrated in
the previous tasks.

You may wish to run the code from previous sessions before starting, to
ensure that you are working with the most up to date `vaccine`
data.frame that includes any cleaning, labelling, reclassification or
other edits to key variables that you have already made.

You can create different types of design (with and without weights,
stratification or clustering) using the `srvyr::as_survey_design()`
command as the input to `sitrep::tab_survey()` .

Remember that the formula for calculating the design effect $deff$ was
presented in task 2.2. You can use the same formula to solve for $rho$
(the intra-cluster correlation coefficient) by extracting the design
effect from the output of the `sitrep::tab_survey()` command that you
will be using to calculate vaccine coverage.

**Code for table 4.5.1:**

*A - simple random sampling:*

In the first code chunk, we will set the survey design for simple random
sampling. Note that there is no design effect, because there are no
strata, clusters or weights in this design. We can represent this with
1.

```{r vce_451_srs}

#####################################
# 01. SIMPLE RANDOM SAMPLING
#####################################

# Use this first entry as the base row
# Results for the other survey designs can be appended to the same table

# Create new table of full vaccine coverage by (a) simple random sampling:
table451 <- vaccine %>% 
  
  # Convert vaccrec to character:
  mutate(vaccrec = as.character(vaccrec)) %>% 
  
  # Filter for respondents only:
  dplyr::filter(vaccrec == "Respondents") %>% 
  
  # Create survey design for SRS:
  srvyr::as_survey_design(ids = 1, 
                          weights = NULL, 
                          strata = NULL) %>% 
  
  # Create proportions for fully vaccinated:
  sitrep::tab_survey(vacful,           # The variable to calculate proportions on
                     strata = NULL,    # SRS has no strata
                     keep = c(1),      # The value of interest (fully vaccinated)
                     wide = FALSE,     # Long format better for a lot of strata
                     deff = TRUE,      # Include the design effect in the output
                     pretty = FALSE) %>% # Do not merge VCE and 95% CI yet
  
  # Add a design column:
  mutate(design = c("Simple random sampling")) %>% 
  
  # Update the design effect where NA to 1 (representing no effect):
  mutate(deff = case_when(is.na(deff) ~ 1))
  
```

*B - Sampling with weights:*

We can compute vaccine coverage with weights by repeating the steps in
the previous chunk, but this time including the `Sample_weights`
variable in the survey design. The results can then be appended to the
previous table.

```{r vce_451_weights}

#####################################
# 02. SAMPLING WITH WEIGHTS
#####################################

# Create new table of full vaccine coverage by (b) sampling with weights:
table451b <- vaccine %>% 
  
  # Convert vaccrec to character:
  mutate(vaccrec = as.character(vaccrec)) %>% 
  
  # Filter for respondents only:
  dplyr::filter(vaccrec == "Respondents") %>% 
  
  # Create survey design for sampling with weights:
  srvyr::as_survey_design(ids = 1, 
                          weights = Sample_weights, 
                          strata = NULL) %>% 
  
  # Create proportions for fully vaccinated:
  sitrep::tab_survey(vacful,           # The variable to calculate proportions on
                     strata = NULL,    # Weighted sampling has no strata
                     keep = c(1),      # The value of interest (fully vaccinated)
                     wide = FALSE,     # Long format better for a lot of strata
                     deff = TRUE,      # Include the design effect in the output
                     pretty = FALSE) %>% # Do not merge VCE and 95% CI yet
  
  # Add a design column:
  mutate(design = c("Sample weights")) 

############################
# Append to the first table
###########################

table451 <- bind_rows(table451, table451b)

```

*C - Sampling with weights and clustering:*

As before, we can repeat the same code, this time adding `school`
classes as clusters to the `ids` argument in the call to survey design:

```{r vce_451_clusters}

#######################################
# 03. CLUSTER SAMPLING WITH WEIGHTS
#######################################

# Create new table of full vaccine coverage by (C) cluster sampling with weights:
table451b <- vaccine %>% 
  
  # Convert vaccrec to character:
  mutate(vaccrec = as.character(vaccrec)) %>% 
  
  # Filter for respondents only:
  dplyr::filter(vaccrec == "Respondents") %>% 
  
  # Create survey design for sampling with weights:
  srvyr::as_survey_design(ids = school, 
                          weights = Sample_weights, 
                          strata = NULL) %>% 
  
  # Create proportions for fully vaccinated:
  sitrep::tab_survey(vacful,           # The variable to calculate proportions on
                     strata = NULL,    # Weighted sampling has no strata
                     keep = c(1),      # The value of interest (fully vaccinated)
                     wide = FALSE,     # Long format better for a lot of strata
                     deff = TRUE,      # Include the design effect in the output
                     pretty = FALSE) %>% # Do not merge VCE and 95% CI yet
  
  # Add a design column:
  mutate(design = c("Sample weights + clusters")) 

############################
# Append to the first table
###########################

table451 <- bind_rows(table451, table451b)

```

*D - Cluster sampling with weights and strata:*

We can again repeat the same code, this time adding the `strata` to the
survey design. We will not add strata to the `tab_survey()` command,
however, as to complete table 4.5.1, we need the total population
estimate rather than the estimates for each stratum. The stratification
is however taken into account in the survey design.

We will also round up the results to make them easier to read, and print
them to a `flextable()` .

```{r vce_451_strata}

#########################################
# 04. CLUSTER SAMPLING, WEIGHTS & STRATA
#########################################

# Create table of full vaccine coverage by (d) cluster sampling, weights & strata:
table451b <- vaccine %>% 
  
  # Convert vaccrec to character:
  mutate(vaccrec = as.character(vaccrec)) %>% 
  
  # Convert strata to character:
  mutate(strata = as.character(strata)) %>% 
  
  # Filter for respondents only:
  dplyr::filter(vaccrec == "Respondents") %>% 
  
  # Create survey design for sampling with weights, clusters & strata:
  srvyr::as_survey_design(ids = school, 
                          weights = Sample_weights, 
                          strata = strata) %>% 
  
  # Create proportions for fully vaccinated:
  sitrep::tab_survey(vacful,           # The variable to calculate proportions on
                     strata = NULL,    # To get the total we will leave this NULL
                     keep = c(1),      # The value of interest (fully vaccinated)
                     wide = FALSE,     # Long format better for a lot of strata
                     deff = TRUE,      # Include the design effect in the output
                     pretty = FALSE) %>% # Do not merge VCE and 95% CI yet
  
  # Add a design column:
  mutate(design = c("Sample weights + clusters + strata")) 


############################
# Append to the first table
###########################

table451 <- bind_rows(table451, table451b)

```

Now that the table is complete, we can tidy up the decimal points and
convert the estimates and confidence intervals to percentages to make
them easier to read.

```{r vce_451_printab}

# Create publishable table of results:
table451pub <- table451 %>% 
  
  # Now we can convert the estimates and 95% CI to percentages:
  mutate(across(c(proportion, proportion_low, proportion_upp), 
                ~ percent(.x, accuracy = 0.01))) %>% 
  
  # And finally we can trim the decimal places for other columns:
  mutate(deff = round(x = deff, digits = 2)) %>% 
  
  # Create merged column for 95% CIs:
  mutate(CI95 = paste0("[", 
                       proportion_low, 
                       " - ", 
                       proportion_upp, 
                       "]")) %>% 
  
  # Select the columns to print:
  dplyr::select(design, 
                deff, 
                n, 
                proportion, 
                CI95) %>% 
  
  # Lastly we can convert it to a flextable for printing:
  flextable::flextable() %>% 
  
  # Add nice theme:
  flextable::theme_booktabs(bold_header = TRUE) %>% 
  
  # Add labels:
  flextable::set_header_labels(values = list(design = "Survey design", 
                                             deff = "Design effect",
                                             n = "VCE (n)", 
                                             proportion = "VCE (%)", 
                                             CI95 = "95% CI")) %>% 
  
  # Adjust column widths to fit text:
  flextable::set_table_properties(layout = "autofit") %>% 
  
  # Right-align last 2 columns (weighted VCE and 95% CI):
  flextable::align(j = 4:5, align = "right", part = "all")

```

*E - Estimating the intra-class correlation coefficient:*

We can solve for $rho$ (intra-class correlation coefficient) using the
equation that was presented in task 2.2, with the following values as
input:

-   Mean school class (cluster) size: **20**

-   Design effect from the weighted, stratified cluster sampling:
    **2.36**

This can be calculated as follows:

$$
rho = \frac {(deff - 1)} {(n -1)}
$$

where:

$rho$ = intra-class correlation coefficient

$deff$ = design effect

$n$ = mean size of clusters

```{r calc_icc_b}

# Calculate ICC:
study_rho <- (2.36 - 1) / (20 - 1)

```

**Code for table 4.5.2**

In this section, we will include weights, clusters and strata in all the
survey designs and estimate vaccine coverage (*n* and %), 95% confidence
intervals and the design effect for:

1.  Each vaccine, separately : dtp3yn, dtp4yn, dtp5yn, mmr1yn, mmr2yn,
    hibprmyn, hibfulyn, hbv3yn, mnc1yn, pne1yn and var1yn) ;

2.  For DTP-3 (dtp3yn) also stratify by minority and urban/rural
    residence;

3.  For complete vaccination (`vacful`) also stratify by minority and
    urban/rural residence;

4.  For timeliness of vaccination (`vactime`) also stratify by minority
    and urban / rural residence.

We will then combine the results in a single table as for the previous
section.

Because there are a large number of variables, we will first define a
helper function which we can use once we have created the first output
table.

The function is called `vactab_adder()` and has the following arguments:

-   *designtab* : a survey design object

-   *varname* : the name of the variable that you wish to use to
    estimate vaccine coverage

-   *stratum* : the name of the variable that you wish to use to
    stratify the results

-   *restable* : the name of an existing results table that you would
    like to add new results to.

```{r finaltab_vactab_adder}

#########################################
# FUNCTION VACTAB_ADDER
#########################################

# Define function:
vactab_adder <- function(designtab, 
                         varname,
                         stratum = NULL,
                         restable ){
  
  # Unquote the variable to estimate on:
  varname = enquo(varname)
  
  # Check if stratum is not null:
  if(!is.null(stratum)){
    
    # Unquote stratum variable:
    stratum = enquo(stratum)
    
    # Input survey design:
    btab = designtab %>% 
    
    # Add variable to estimate:
    sitrep::tab_survey(UQ(varname),           
                     strata = UQ(stratum),    
                     keep = c(1),
                     na.rm = TRUE,
                     wide = FALSE,     
                     deff = TRUE,      
                     pretty = FALSE) %>% 
      
    # Rename stratifier column to stratum:
    rename(stratum = UQ(stratum)) %>% 
    
    # Remove rows with missing values:
    filter(!is.na(stratum))

  } else if (is.null(stratum)) {
    
  # Input survey design:
  btab = designtab %>% 
    
    # Add variable to estimate:
    sitrep::tab_survey(UQ(varname),           
                     strata = NULL,    
                     keep = c(1),
                     na.rm = TRUE,
                     wide = FALSE,     
                     deff = TRUE,      
                     pretty = FALSE) %>% 
  
    # Create stratum column:
    mutate(stratum = "Overall")

  }
  
  # Bind new table to base table:
  restable = bind_rows(restable, btab)
  
  # Return results in updated table:
  return(restable)
  
}

```

We will first create the survey design (which is the same for the whole
table):

```{r finaltab_design}

vce_design <- vaccine %>% 
  
  # Convert vaccrec to character:
  mutate(vaccrec = as.character(vaccrec)) %>% 
  
  # Convert strata to character:
  mutate(strata = as.character(strata)) %>% 
  
  # Filter for respondents only:
  dplyr::filter(vaccrec == "Respondents") %>% 
  
    # Create survey design for sampling with weights, clusters & strata:
  srvyr::as_survey_design(ids = school, 
                          weights = Sample_weights, 
                          strata = strata) 


```

Next, we will create the first results for DTP3 stratified by minority
group using the `tab_survey()` function from the `sitrep` package
directly:


```{r finaltab_dtp3minority}

####################################
# Estimate VC for DTP3 by minority:
####################################

restab <- vce_design %>% 
  
  # Create proportions for DTP3 by minority:
  sitrep::tab_survey(dtp3yn,           
                     strata = minority,    
                     keep = c(1),
                     na.rm = TRUE,
                     wide = FALSE,     
                     deff = TRUE,      
                     pretty = FALSE) %>% 
  
  # Rename minority column to stratum:
  rename(stratum = minority) %>% 
  
  # Remove row with missing values:
  filter(!is.na(stratum))

```


For the DTP3 vaccine coverage estimate by urban / rural area of residence, we can now use the `vactab_adder()` function to update the existing `restable`:

```{r finaltab_dtp3urban}

#####################################
# DTP3 by urban rural area:
#####################################

# Add VCE for DTP3 by urban rural stratification:
restab <- vactab_adder(designtab = vce_design, 
                       varname = "dtp3yn", 
                       stratum = "urban", 
                       restable = restab)

```

Because the next set of variables to tabulate do not require stratification, we can add them by feeding them into the `vactab_adder()` function with a `forloop`.

```{r finaltab_loop_vaccines}

# Create a list of variables to estimate vaccine coverage with:
varlist <- c("dtp4yn", 
             "dtp5yn", 
             "mmr1yn", 
             "mmr2yn",
             "hibprmyn", 
             "hibfulyn", 
             "hbv3yn", 
             "mnc1yn", 
             "pne1yn", 
             "var1yn")

# Now we can pass the variables to the table in a for-loop:
for(var in 1:length(varlist)){
  
  # Pass them through the function:
  restab <- vactab_adder(designtab = vce_design, 
                         varname = varlist[var],
                         stratum = NULL,
                         restable = restab)
}

```

Next, we can look at vaccine completeness stratified by minority group and urban / rural residence.  These can also quickly be added to the table using the `vactab_adder()` function:

```{r finaltab_completeness}

# First we will stratify by minority group:
restab <- vactab_adder(designtab = vce_design, 
                       varname = "vacful", 
                       stratum = "minority", 
                       restable = restab)

# Next we can add urban / rural strata:
restab <- vactab_adder(designtab = vce_design, 
                       varname = "vacful", 
                       stratum = "urban", 
                       restable = restab)


```


Finally we can add vaccination timeliness to the table:

```{r finaltab_timeliness}

# First we will stratify by minority group:
restab <- vactab_adder(designtab = vce_design, 
                       varname = "vactime", 
                       stratum = "minority", 
                       restable = restab)

# Next we can add urban / rural strata:
restab <- vactab_adder(designtab = vce_design, 
                       varname = "vactime", 
                       stratum = "urban", 
                       restable = restab)

```


Lastly, we can tidy up the decimals and add percentages to make the results easier to read, as before.

```{r finaltab_printable}

# Create publishable table of results:
restabpub <- restab %>% 
  
  # Now we can convert the estimates and 95% CI to percentages:
  mutate(across(c(proportion, proportion_low, proportion_upp), 
                ~ percent(.x, accuracy = 0.01))) %>% 
  
  # And finally we can trim the decimal places for other columns:
  mutate(across(c(n, deff), 
                ~ round(.x, digits = 2))) %>% 
  
  # Create merged column for 95% CIs:
  mutate(CI95 = paste0("[", 
                       proportion_low, 
                       " - ", 
                       proportion_upp, 
                       "]")) %>% 
  
  # Select the columns to print:
  dplyr::select(value,
                variable,
                stratum,
                deff, 
                n, 
                proportion, 
                CI95) %>% 
  
  # Lastly we can convert it to a flextable for printing:
  flextable::flextable() %>% 
  
  # Add nice theme:
  flextable::theme_booktabs(bold_header = TRUE) %>% 
  
  # Add labels:
  flextable::set_header_labels(values = list(value = "Vaccinated",
                                             variable = "Vaccine",
                                             stratum = "Stratum",
                                             deff = "Design effect",
                                             n = "VCE (n)", 
                                             proportion = "VCE (%)", 
                                             CI95 = "95% CI")) %>% 
  
  # Adjust column widths to fit text:
  flextable::set_table_properties(layout = "autofit") %>% 
  
  # Right-align last 2 columns (weighted VCE and 95% CI):
  flextable::align(j = 6:7, align = "right", part = "all")


```


